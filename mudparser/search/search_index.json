{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MudParser","text":"<p>Production-ready parser for MUD (Manufacturer Usage Description) profiles.</p> <p> </p> <p>MudParser is a Python library for parsing, validating, and exporting MUD profiles as defined in:</p> <ul> <li>RFC 8520 - Manufacturer Usage Description Specification</li> <li>RFC 9761 - MUD (D)TLS Profiles for IoT Devices</li> </ul>"},{"location":"#what-is-mud","title":"What is MUD?","text":"<p>MUD (Manufacturer Usage Description) is a standard that allows IoT device manufacturers to formally describe the network behavior their devices require. This enables network administrators to automatically configure access control policies that restrict IoT devices to only the network communications they need.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Complete RFC 8520 Support - Parse all MUD profile elements including ACLs, policies, and MUD-specific matches</li> <li>RFC 9761 TLS Profiles - Support for TLS/DTLS profile constraints</li> <li>Comprehensive Validation - Validate profiles for RFC compliance and best practices</li> <li>Multiple Export Formats:<ul> <li>JSON and YAML data formats</li> <li>iptables (Linux)</li> <li>nftables (Linux)</li> <li>Cisco IOS ACLs</li> <li>pfSense XML</li> </ul> </li> <li>Modern Python - Built with Python 3.10+, Pydantic v2, and type hints</li> <li>CLI Tool - Full-featured command-line interface</li> <li>Async Support - Async URL fetching for MUD profiles</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from mudparser import MUDParser\n\n# Parse a MUD file\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Access device information\nprint(f\"Device: {parser.mud.systeminfo}\")\nprint(f\"Supported: {parser.mud.is_supported}\")\n\n# Validate the profile\nerrors = parser.validate()\nif not errors:\n    print(\"Profile is valid!\")\n\n# Export to iptables rules\nrules = parser.export.to_iptables(device_ip=\"192.168.1.100\")\nprint(rules)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install mudparser\n</code></pre> <p>For all features including the demo application:</p> <pre><code>pip install mudparser[all]\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li> <p>:material-download:{ .lg .middle } Installation</p> <p>Get started with installing MudParser</p> <p>Installation Guide \u2192</p> </li> <li> <p>:material-rocket-launch:{ .lg .middle } Quick Start</p> <p>Parse your first MUD profile in 5 minutes</p> <p>Quick Start \u2192</p> </li> <li> <p>:material-book-open-variant:{ .lg .middle } User Guide</p> <p>Learn how to use all features</p> <p>User Guide \u2192</p> </li> <li> <p>:material-api:{ .lg .middle } API Reference</p> <p>Detailed API documentation</p> <p>API Reference \u2192</p> </li> </ul>"},{"location":"#license","title":"License","text":"<p>MudParser is released under the MIT License. See the LICENSE file for details.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Original mudparser by Omar Ilias EL MIMOUNI (NIST)</li> <li>IETF OPSAWG for the MUD specification</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>Install MudParser from PyPI:</p> <pre><code>pip install mudparser\n</code></pre>"},{"location":"installation/#installation-with-extras","title":"Installation with Extras","text":"<p>MudParser provides optional dependencies for additional features:</p>"},{"location":"installation/#demo-application-streamlit","title":"Demo Application (Streamlit)","text":"<pre><code>pip install mudparser[demo]\n</code></pre>"},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<pre><code>pip install mudparser[dev]\n</code></pre>"},{"location":"installation/#documentation-building","title":"Documentation Building","text":"<pre><code>pip install mudparser[docs]\n</code></pre>"},{"location":"installation/#all-features","title":"All Features","text":"<pre><code>pip install mudparser[all]\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development, clone the repository and install in editable mode:</p> <pre><code># Clone the repository\ngit clone https://github.com/elmiomar/mudparser.git\ncd mudparser\n\n# Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in editable mode with dev dependencies\npip install -e \".[dev]\"\n\n# Install pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify it works:</p> <pre><code># Check CLI is available\nmudparser --version\n\n# Or in Python\npython -c \"import mudparser; print(mudparser.__version__)\"\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>MudParser depends on the following packages:</p> Package Version Purpose pydantic &gt;=2.0 Data validation and models pyyaml &gt;=6.0 YAML export rich &gt;=13.0 CLI output formatting typer &gt;=0.9 CLI framework httpx &gt;=0.25 HTTP client for URL fetching <p>Optional dependencies:</p> Package Extra Purpose streamlit demo Web demo application pytest dev Testing mypy dev Type checking ruff dev Linting mkdocs-material docs Documentation"},{"location":"installation/#platform-support","title":"Platform Support","text":"<p>MudParser is tested on:</p> <ul> <li>Linux (Ubuntu, Debian, CentOS)</li> <li>macOS (10.15+)</li> <li>Windows (10, 11)</li> </ul>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#importerror-no-module-named-mudparser","title":"ImportError: No module named 'mudparser'","text":"<p>Ensure you're using the correct Python environment:</p> <pre><code>which python\npip list | grep mudparser\n</code></pre>"},{"location":"installation/#permission-denied-on-installation","title":"Permission Denied on Installation","text":"<p>Use <code>--user</code> flag or a virtual environment:</p> <pre><code>pip install --user mudparser\n</code></pre>"},{"location":"installation/#outdated-pip","title":"Outdated pip","text":"<p>Update pip before installing:</p> <pre><code>pip install --upgrade pip\npip install mudparser\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get started with MudParser in 5 minutes.</p>"},{"location":"quickstart/#your-first-mud-profile","title":"Your First MUD Profile","text":"<p>Let's parse and analyze a MUD profile. First, create a sample MUD file:</p> device.mud.json<pre><code>{\n  \"ietf-mud:mud\": {\n    \"mud-version\": 1,\n    \"mud-url\": \"https://example.com/mydevice.json\",\n    \"last-update\": \"2024-01-15T10:00:00Z\",\n    \"cache-validity\": 48,\n    \"is-supported\": true,\n    \"systeminfo\": \"My IoT Device\",\n    \"from-device-policy\": {\n      \"access-lists\": {\n        \"access-list\": [{\"name\": \"from-ipv4\"}]\n      }\n    },\n    \"to-device-policy\": {\n      \"access-lists\": {\n        \"access-list\": [{\"name\": \"to-ipv4\"}]\n      }\n    }\n  },\n  \"ietf-access-control-list:access-lists\": {\n    \"acl\": [\n      {\n        \"name\": \"from-ipv4\",\n        \"type\": \"ipv4-acl-type\",\n        \"aces\": {\n          \"ace\": [\n            {\n              \"name\": \"allow-https-out\",\n              \"matches\": {\n                \"ipv4\": {\"protocol\": 6},\n                \"tcp\": {\n                  \"destination-port\": {\"operator\": \"eq\", \"port\": 443}\n                }\n              },\n              \"actions\": {\"forwarding\": \"accept\"}\n            }\n          ]\n        }\n      },\n      {\n        \"name\": \"to-ipv4\",\n        \"type\": \"ipv4-acl-type\",\n        \"aces\": {\n          \"ace\": [\n            {\n              \"name\": \"allow-https-response\",\n              \"matches\": {\n                \"ipv4\": {\"protocol\": 6},\n                \"tcp\": {\n                  \"source-port\": {\"operator\": \"eq\", \"port\": 443}\n                }\n              },\n              \"actions\": {\"forwarding\": \"accept\"}\n            }\n          ]\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"quickstart/#parsing-the-profile","title":"Parsing the Profile","text":"<pre><code>from mudparser import MUDParser\n\n# Parse from file\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Access basic information\nprint(f\"Device: {parser.mud.systeminfo}\")\nprint(f\"MUD URL: {parser.mud.mud_url}\")\nprint(f\"Version: {parser.mud.mud_version}\")\nprint(f\"Supported: {parser.mud.is_supported}\")\n</code></pre> <p>Output: <pre><code>Device: My IoT Device\nMUD URL: https://example.com/mydevice.json\nVersion: 1\nSupported: True\n</code></pre></p>"},{"location":"quickstart/#exploring-the-profile","title":"Exploring the Profile","text":"<pre><code># Get a summary\nsummary = parser.get_summary()\nprint(f\"Total ACLs: {summary['total_acls']}\")\nprint(f\"Total Rules: {summary['total_rules']}\")\nprint(f\"DNS Names: {summary['dns_names']}\")\nprint(f\"Ports: {summary['ports']}\")\n\n# List ACLs\nfor acl in parser.profile.acls.acl:\n    print(f\"ACL: {acl.name} ({acl.acl_type.value})\")\n    for entry in acl.entries:\n        print(f\"  - {entry.name}: {entry.actions.forwarding.value}\")\n</code></pre>"},{"location":"quickstart/#validating-the-profile","title":"Validating the Profile","text":"<pre><code># Validate for RFC 8520 compliance\nerrors = parser.validate()\n\nif errors:\n    print(\"Validation issues:\")\n    for error in errors:\n        print(f\"  - {error}\")\nelse:\n    print(\"Profile is valid!\")\n\n# Strict validation (raises exception on any issue)\ntry:\n    parser.validate(strict=True)\n    print(\"Passed strict validation!\")\nexcept MUDValidationError as e:\n    print(f\"Validation failed: {e}\")\n</code></pre>"},{"location":"quickstart/#exporting-to-firewall-rules","title":"Exporting to Firewall Rules","text":"<pre><code># Export to iptables\niptables_rules = parser.export.to_iptables(device_ip=\"192.168.1.100\")\nprint(iptables_rules)\n\n# Export to nftables\nnftables_rules = parser.export.to_nftables(device_ip=\"192.168.1.100\")\n\n# Export to Cisco ACL\ncisco_rules = parser.export.to_cisco_acl()\n\n# Export to pfSense XML\npfsense_rules = parser.export.to_pfsense(device_ip=\"192.168.1.100\")\n\n# Export to JSON/YAML\njson_output = parser.export.to_json(indent=2)\nyaml_output = parser.export.to_yaml()\n</code></pre>"},{"location":"quickstart/#using-the-cli","title":"Using the CLI","text":"<p>MudParser also provides a command-line interface:</p> <pre><code># Validate a MUD file\nmudparser validate device.mud.json\n\n# Show profile information\nmudparser info device.mud.json\n\n# Print rules in human-readable format\nmudparser rules device.mud.json\n\n# Export to iptables\nmudparser export device.mud.json -f iptables -d 192.168.1.100\n\n# Export to file\nmudparser export device.mud.json -f nftables -d 192.168.1.100 -o rules.nft\n\n# Fetch from URL\nmudparser fetch https://example.com/device.mud.json --validate\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about parsing MUD files</li> <li>Understand validation options</li> <li>Explore export formats</li> <li>See the full API reference</li> </ul>"},{"location":"api-reference/exporters/","title":"Exporters API Reference","text":""},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter","title":"<code>mudparser.exporters.base.MUDExporter</code>","text":"<p>Main exporter class for MUD profiles.</p> <p>Provides methods to export MUD profiles to various formats including JSON, YAML, and firewall rules.</p> Example <p>from mudparser import MUDParser parser = MUDParser.from_file(\"device.mud.json\")</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>class MUDExporter:\n    \"\"\"\n    Main exporter class for MUD profiles.\n\n    Provides methods to export MUD profiles to various formats\n    including JSON, YAML, and firewall rules.\n\n    Example:\n        &gt;&gt;&gt; from mudparser import MUDParser\n        &gt;&gt;&gt; parser = MUDParser.from_file(\"device.mud.json\")\n        &gt;&gt;&gt; # Export to JSON\n        &gt;&gt;&gt; json_output = parser.export.to_json()\n        &gt;&gt;&gt; # Export to iptables rules\n        &gt;&gt;&gt; rules = parser.export.to_iptables(device_ip=\"192.168.1.100\")\n    \"\"\"\n\n    def __init__(self, profile: \"MUDProfile\") -&gt; None:\n        \"\"\"\n        Initialize the exporter.\n\n        Args:\n            profile: The MUD profile to export.\n        \"\"\"\n        self._profile = profile\n\n    @property\n    def profile(self) -&gt; \"MUDProfile\":\n        \"\"\"Get the profile being exported.\"\"\"\n        return self._profile\n\n    # =========================================================================\n    # Data Format Exports\n    # =========================================================================\n\n    def to_json(self, indent: int = 2, sort_keys: bool = False) -&gt; str:\n        \"\"\"\n        Export the profile to JSON format.\n\n        Args:\n            indent: Indentation level for pretty printing.\n            sort_keys: Whether to sort dictionary keys.\n\n        Returns:\n            JSON string representation.\n        \"\"\"\n        return json.dumps(\n            self._profile.to_dict(),\n            indent=indent,\n            sort_keys=sort_keys,\n            default=str,\n        )\n\n    def to_yaml(self, default_flow_style: bool = False) -&gt; str:\n        \"\"\"\n        Export the profile to YAML format.\n\n        Args:\n            default_flow_style: Use flow style for collections.\n\n        Returns:\n            YAML string representation.\n        \"\"\"\n        # Convert datetime objects to strings\n        data = self._convert_for_yaml(self._profile.to_dict())\n        return yaml.dump(\n            data,\n            default_flow_style=default_flow_style,\n            sort_keys=False,\n            allow_unicode=True,\n        )\n\n    def _convert_for_yaml(self, obj: Any) -&gt; Any:\n        \"\"\"Convert objects for YAML serialization.\"\"\"\n        if isinstance(obj, dict):\n            return {k: self._convert_for_yaml(v) for k, v in obj.items()}\n        elif isinstance(obj, list):\n            return [self._convert_for_yaml(item) for item in obj]\n        elif hasattr(obj, \"isoformat\"):\n            return obj.isoformat()\n        return obj\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Export the profile to a dictionary.\n\n        Returns:\n            Dictionary representation.\n        \"\"\"\n        return self._profile.to_dict()\n\n    # =========================================================================\n    # Firewall Rule Exports\n    # =========================================================================\n\n    def to_iptables(\n        self,\n        device_ip: str,\n        device_interface: str = \"eth0\",\n        chain_prefix: str = \"MUD\",\n        include_comments: bool = True,\n    ) -&gt; str:\n        \"\"\"\n        Export the profile to iptables rules.\n\n        Args:\n            device_ip: IP address of the IoT device.\n            device_interface: Network interface for the device.\n            chain_prefix: Prefix for custom chain names.\n            include_comments: Include rule comments.\n\n        Returns:\n            iptables rule commands.\n        \"\"\"\n        from mudparser.exporters.iptables import IPTablesExporter\n\n        exporter = IPTablesExporter(self._profile)\n        return exporter.export(\n            device_ip=device_ip,\n            device_interface=device_interface,\n            chain_prefix=chain_prefix,\n            include_comments=include_comments,\n        )\n\n    def to_nftables(\n        self,\n        device_ip: str,\n        table_name: str = \"mud_rules\",\n        include_comments: bool = True,\n    ) -&gt; str:\n        \"\"\"\n        Export the profile to nftables rules.\n\n        Args:\n            device_ip: IP address of the IoT device.\n            table_name: Name for the nftables table.\n            include_comments: Include rule comments.\n\n        Returns:\n            nftables configuration.\n        \"\"\"\n        from mudparser.exporters.nftables import NFTablesExporter\n\n        exporter = NFTablesExporter(self._profile)\n        return exporter.export(\n            device_ip=device_ip,\n            table_name=table_name,\n            include_comments=include_comments,\n        )\n\n    def to_cisco_acl(\n        self,\n        acl_number_start: int = 100,\n        include_remarks: bool = True,\n    ) -&gt; str:\n        \"\"\"\n        Export the profile to Cisco IOS ACL format.\n\n        Args:\n            acl_number_start: Starting ACL number.\n            include_remarks: Include ACL remarks.\n\n        Returns:\n            Cisco IOS ACL configuration.\n        \"\"\"\n        from mudparser.exporters.cisco import CiscoACLExporter\n\n        exporter = CiscoACLExporter(self._profile)\n        return exporter.export(\n            acl_number_start=acl_number_start,\n            include_remarks=include_remarks,\n        )\n\n    def to_pfsense(\n        self,\n        device_ip: str,\n        interface: str = \"lan\",\n    ) -&gt; str:\n        \"\"\"\n        Export the profile to pfSense XML format.\n\n        Args:\n            device_ip: IP address of the IoT device.\n            interface: pfSense interface name.\n\n        Returns:\n            pfSense filter rules in XML format.\n        \"\"\"\n        from mudparser.exporters.pfsense import PfSenseExporter\n\n        exporter = PfSenseExporter(self._profile)\n        return exporter.export(\n            device_ip=device_ip,\n            interface=interface,\n        )\n\n    # =========================================================================\n    # Format Detection\n    # =========================================================================\n\n    def export(self, format: ExportFormat | str, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Export to the specified format.\n\n        Args:\n            format: The export format.\n            **kwargs: Format-specific options.\n\n        Returns:\n            Exported content as string.\n\n        Raises:\n            MUDExportError: If the format is not supported.\n        \"\"\"\n        if isinstance(format, str):\n            try:\n                format = ExportFormat(format.lower())\n            except ValueError:\n                raise MUDExportError(\n                    f\"Unsupported export format: {format}\",\n                    export_format=format,\n                    reason=f\"Supported formats: {', '.join(f.value for f in ExportFormat)}\",\n                )\n\n        match format:\n            case ExportFormat.JSON:\n                return self.to_json(**kwargs)\n            case ExportFormat.YAML:\n                return self.to_yaml(**kwargs)\n            case ExportFormat.IPTABLES:\n                return self.to_iptables(**kwargs)\n            case ExportFormat.NFTABLES:\n                return self.to_nftables(**kwargs)\n            case ExportFormat.CISCO:\n                return self.to_cisco_acl(**kwargs)\n            case ExportFormat.PFSENSE:\n                return self.to_pfsense(**kwargs)\n            case _:\n                raise MUDExportError(\n                    f\"Unsupported export format: {format}\",\n                    export_format=str(format),\n                )\n\n    # =========================================================================\n    # Utility Methods\n    # =========================================================================\n\n    def get_summary(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get a summary of what will be exported.\n\n        Returns:\n            Dictionary with export summary information.\n        \"\"\"\n        from_acls = self._profile.get_from_device_acls()\n        to_acls = self._profile.get_to_device_acls()\n\n        return {\n            \"device_info\": self._profile.mud.systeminfo,\n            \"from_device_rules\": sum(len(acl.entries) for acl in from_acls),\n            \"to_device_rules\": sum(len(acl.entries) for acl in to_acls),\n            \"total_rules\": sum(len(acl.entries) for acl in self._profile.acls.acl),\n            \"dns_names\": list(self._profile.get_all_dns_names()),\n            \"ports\": {k: list(v) for k, v in self._profile.get_all_ports().items()},\n            \"supported_formats\": [f.value for f in ExportFormat],\n        }\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter--export-to-json","title":"Export to JSON","text":"<p>json_output = parser.export.to_json()</p>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter--export-to-iptables-rules","title":"Export to iptables rules","text":"<p>rules = parser.export.to_iptables(device_ip=\"192.168.1.100\")</p>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.profile","title":"<code>profile</code>  <code>property</code>","text":"<p>Get the profile being exported.</p>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.__init__","title":"<code>__init__(profile)</code>","text":"<p>Initialize the exporter.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>'MUDProfile'</code> <p>The MUD profile to export.</p> required Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def __init__(self, profile: \"MUDProfile\") -&gt; None:\n    \"\"\"\n    Initialize the exporter.\n\n    Args:\n        profile: The MUD profile to export.\n    \"\"\"\n    self._profile = profile\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.export","title":"<code>export(format, **kwargs)</code>","text":"<p>Export to the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>ExportFormat | str</code> <p>The export format.</p> required <code>**kwargs</code> <code>Any</code> <p>Format-specific options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Exported content as string.</p> <p>Raises:</p> Type Description <code>MUDExportError</code> <p>If the format is not supported.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def export(self, format: ExportFormat | str, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Export to the specified format.\n\n    Args:\n        format: The export format.\n        **kwargs: Format-specific options.\n\n    Returns:\n        Exported content as string.\n\n    Raises:\n        MUDExportError: If the format is not supported.\n    \"\"\"\n    if isinstance(format, str):\n        try:\n            format = ExportFormat(format.lower())\n        except ValueError:\n            raise MUDExportError(\n                f\"Unsupported export format: {format}\",\n                export_format=format,\n                reason=f\"Supported formats: {', '.join(f.value for f in ExportFormat)}\",\n            )\n\n    match format:\n        case ExportFormat.JSON:\n            return self.to_json(**kwargs)\n        case ExportFormat.YAML:\n            return self.to_yaml(**kwargs)\n        case ExportFormat.IPTABLES:\n            return self.to_iptables(**kwargs)\n        case ExportFormat.NFTABLES:\n            return self.to_nftables(**kwargs)\n        case ExportFormat.CISCO:\n            return self.to_cisco_acl(**kwargs)\n        case ExportFormat.PFSENSE:\n            return self.to_pfsense(**kwargs)\n        case _:\n            raise MUDExportError(\n                f\"Unsupported export format: {format}\",\n                export_format=str(format),\n            )\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.get_summary","title":"<code>get_summary()</code>","text":"<p>Get a summary of what will be exported.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with export summary information.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def get_summary(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get a summary of what will be exported.\n\n    Returns:\n        Dictionary with export summary information.\n    \"\"\"\n    from_acls = self._profile.get_from_device_acls()\n    to_acls = self._profile.get_to_device_acls()\n\n    return {\n        \"device_info\": self._profile.mud.systeminfo,\n        \"from_device_rules\": sum(len(acl.entries) for acl in from_acls),\n        \"to_device_rules\": sum(len(acl.entries) for acl in to_acls),\n        \"total_rules\": sum(len(acl.entries) for acl in self._profile.acls.acl),\n        \"dns_names\": list(self._profile.get_all_dns_names()),\n        \"ports\": {k: list(v) for k, v in self._profile.get_all_ports().items()},\n        \"supported_formats\": [f.value for f in ExportFormat],\n    }\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.to_cisco_acl","title":"<code>to_cisco_acl(acl_number_start=100, include_remarks=True)</code>","text":"<p>Export the profile to Cisco IOS ACL format.</p> <p>Parameters:</p> Name Type Description Default <code>acl_number_start</code> <code>int</code> <p>Starting ACL number.</p> <code>100</code> <code>include_remarks</code> <code>bool</code> <p>Include ACL remarks.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Cisco IOS ACL configuration.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def to_cisco_acl(\n    self,\n    acl_number_start: int = 100,\n    include_remarks: bool = True,\n) -&gt; str:\n    \"\"\"\n    Export the profile to Cisco IOS ACL format.\n\n    Args:\n        acl_number_start: Starting ACL number.\n        include_remarks: Include ACL remarks.\n\n    Returns:\n        Cisco IOS ACL configuration.\n    \"\"\"\n    from mudparser.exporters.cisco import CiscoACLExporter\n\n    exporter = CiscoACLExporter(self._profile)\n    return exporter.export(\n        acl_number_start=acl_number_start,\n        include_remarks=include_remarks,\n    )\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.to_dict","title":"<code>to_dict()</code>","text":"<p>Export the profile to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Export the profile to a dictionary.\n\n    Returns:\n        Dictionary representation.\n    \"\"\"\n    return self._profile.to_dict()\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.to_iptables","title":"<code>to_iptables(device_ip, device_interface='eth0', chain_prefix='MUD', include_comments=True)</code>","text":"<p>Export the profile to iptables rules.</p> <p>Parameters:</p> Name Type Description Default <code>device_ip</code> <code>str</code> <p>IP address of the IoT device.</p> required <code>device_interface</code> <code>str</code> <p>Network interface for the device.</p> <code>'eth0'</code> <code>chain_prefix</code> <code>str</code> <p>Prefix for custom chain names.</p> <code>'MUD'</code> <code>include_comments</code> <code>bool</code> <p>Include rule comments.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>iptables rule commands.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def to_iptables(\n    self,\n    device_ip: str,\n    device_interface: str = \"eth0\",\n    chain_prefix: str = \"MUD\",\n    include_comments: bool = True,\n) -&gt; str:\n    \"\"\"\n    Export the profile to iptables rules.\n\n    Args:\n        device_ip: IP address of the IoT device.\n        device_interface: Network interface for the device.\n        chain_prefix: Prefix for custom chain names.\n        include_comments: Include rule comments.\n\n    Returns:\n        iptables rule commands.\n    \"\"\"\n    from mudparser.exporters.iptables import IPTablesExporter\n\n    exporter = IPTablesExporter(self._profile)\n    return exporter.export(\n        device_ip=device_ip,\n        device_interface=device_interface,\n        chain_prefix=chain_prefix,\n        include_comments=include_comments,\n    )\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.to_json","title":"<code>to_json(indent=2, sort_keys=False)</code>","text":"<p>Export the profile to JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>Indentation level for pretty printing.</p> <code>2</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort dictionary keys.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>JSON string representation.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def to_json(self, indent: int = 2, sort_keys: bool = False) -&gt; str:\n    \"\"\"\n    Export the profile to JSON format.\n\n    Args:\n        indent: Indentation level for pretty printing.\n        sort_keys: Whether to sort dictionary keys.\n\n    Returns:\n        JSON string representation.\n    \"\"\"\n    return json.dumps(\n        self._profile.to_dict(),\n        indent=indent,\n        sort_keys=sort_keys,\n        default=str,\n    )\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.to_nftables","title":"<code>to_nftables(device_ip, table_name='mud_rules', include_comments=True)</code>","text":"<p>Export the profile to nftables rules.</p> <p>Parameters:</p> Name Type Description Default <code>device_ip</code> <code>str</code> <p>IP address of the IoT device.</p> required <code>table_name</code> <code>str</code> <p>Name for the nftables table.</p> <code>'mud_rules'</code> <code>include_comments</code> <code>bool</code> <p>Include rule comments.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>nftables configuration.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def to_nftables(\n    self,\n    device_ip: str,\n    table_name: str = \"mud_rules\",\n    include_comments: bool = True,\n) -&gt; str:\n    \"\"\"\n    Export the profile to nftables rules.\n\n    Args:\n        device_ip: IP address of the IoT device.\n        table_name: Name for the nftables table.\n        include_comments: Include rule comments.\n\n    Returns:\n        nftables configuration.\n    \"\"\"\n    from mudparser.exporters.nftables import NFTablesExporter\n\n    exporter = NFTablesExporter(self._profile)\n    return exporter.export(\n        device_ip=device_ip,\n        table_name=table_name,\n        include_comments=include_comments,\n    )\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.to_pfsense","title":"<code>to_pfsense(device_ip, interface='lan')</code>","text":"<p>Export the profile to pfSense XML format.</p> <p>Parameters:</p> Name Type Description Default <code>device_ip</code> <code>str</code> <p>IP address of the IoT device.</p> required <code>interface</code> <code>str</code> <p>pfSense interface name.</p> <code>'lan'</code> <p>Returns:</p> Type Description <code>str</code> <p>pfSense filter rules in XML format.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def to_pfsense(\n    self,\n    device_ip: str,\n    interface: str = \"lan\",\n) -&gt; str:\n    \"\"\"\n    Export the profile to pfSense XML format.\n\n    Args:\n        device_ip: IP address of the IoT device.\n        interface: pfSense interface name.\n\n    Returns:\n        pfSense filter rules in XML format.\n    \"\"\"\n    from mudparser.exporters.pfsense import PfSenseExporter\n\n    exporter = PfSenseExporter(self._profile)\n    return exporter.export(\n        device_ip=device_ip,\n        interface=interface,\n    )\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.MUDExporter.to_yaml","title":"<code>to_yaml(default_flow_style=False)</code>","text":"<p>Export the profile to YAML format.</p> <p>Parameters:</p> Name Type Description Default <code>default_flow_style</code> <code>bool</code> <p>Use flow style for collections.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>YAML string representation.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>def to_yaml(self, default_flow_style: bool = False) -&gt; str:\n    \"\"\"\n    Export the profile to YAML format.\n\n    Args:\n        default_flow_style: Use flow style for collections.\n\n    Returns:\n        YAML string representation.\n    \"\"\"\n    # Convert datetime objects to strings\n    data = self._convert_for_yaml(self._profile.to_dict())\n    return yaml.dump(\n        data,\n        default_flow_style=default_flow_style,\n        sort_keys=False,\n        allow_unicode=True,\n    )\n</code></pre>"},{"location":"api-reference/exporters/#mudparser.exporters.base.ExportFormat","title":"<code>mudparser.exporters.base.ExportFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported export formats.</p> Source code in <code>src/mudparser/exporters/base.py</code> <pre><code>class ExportFormat(str, Enum):\n    \"\"\"Supported export formats.\"\"\"\n\n    JSON = \"json\"\n    YAML = \"yaml\"\n    IPTABLES = \"iptables\"\n    NFTABLES = \"nftables\"\n    CISCO = \"cisco\"\n    PFSENSE = \"pfsense\"\n</code></pre>"},{"location":"api-reference/models/","title":"Models API Reference","text":""},{"location":"api-reference/models/#mud-profile","title":"MUD Profile","text":""},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile","title":"<code>mudparser.models.mud.MUDProfile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A complete MUD Profile.</p> <p>This is the root model representing an entire MUD file, containing both the MUD metadata container and the ACL definitions.</p> <p>Attributes:</p> Name Type Description <code>mud</code> <code>MUDContainer</code> <p>The MUD container with metadata and policy references.</p> <code>acls</code> <code>ACLsContainer</code> <p>The container holding all ACL definitions.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>class MUDProfile(BaseModel):\n    \"\"\"\n    A complete MUD Profile.\n\n    This is the root model representing an entire MUD file, containing\n    both the MUD metadata container and the ACL definitions.\n\n    Attributes:\n        mud: The MUD container with metadata and policy references.\n        acls: The container holding all ACL definitions.\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    mud: MUDContainer = Field(alias=\"ietf-mud:mud\")\n    acls: ACLsContainer = Field(alias=\"ietf-access-control-list:access-lists\")\n\n    # Cached resolved policies\n    _from_device_acls: list[AccessControlList] | None = None\n    _to_device_acls: list[AccessControlList] | None = None\n\n    @classmethod\n    def from_json(cls, data: dict[str, Any]) -&gt; \"MUDProfile\":\n        \"\"\"Create a MUDProfile from JSON data.\"\"\"\n        # Parse ACLs\n        acls_data = data.get(\"ietf-access-control-list:access-lists\", {})\n        acl_list = [AccessControlList.from_json(acl) for acl in acls_data.get(\"acl\", [])]\n\n        # Parse MUD container\n        mud_data = data.get(\"ietf-mud:mud\", {})\n\n        return cls(\n            mud=MUDContainer(**mud_data),\n            acls=ACLsContainer(acl=acl_list),\n        )\n\n    @property\n    def version(self) -&gt; int:\n        \"\"\"Get the MUD version.\"\"\"\n        return self.mud.mud_version\n\n    @property\n    def url(self) -&gt; str:\n        \"\"\"Get the MUD URL.\"\"\"\n        return str(self.mud.mud_url)\n\n    @property\n    def last_update(self) -&gt; datetime:\n        \"\"\"Get the last update timestamp.\"\"\"\n        return self.mud.last_update\n\n    @property\n    def cache_validity(self) -&gt; int:\n        \"\"\"Get the cache validity in hours.\"\"\"\n        return self.mud.cache_validity\n\n    @property\n    def is_supported(self) -&gt; bool:\n        \"\"\"Check if the device is still supported.\"\"\"\n        return self.mud.is_supported\n\n    @property\n    def systeminfo(self) -&gt; str | None:\n        \"\"\"Get the system info string.\"\"\"\n        return self.mud.systeminfo\n\n    def get_acl(self, name: str) -&gt; AccessControlList | None:\n        \"\"\"\n        Get an ACL by name.\n\n        Args:\n            name: The ACL name to look up.\n\n        Returns:\n            The ACL if found, None otherwise.\n        \"\"\"\n        for acl in self.acls.acl:\n            if acl.name == name:\n                return acl\n        return None\n\n    def get_from_device_acls(self) -&gt; list[AccessControlList]:\n        \"\"\"\n        Get all ACLs referenced by the from-device policy.\n\n        Returns:\n            List of ACLs for outbound traffic control.\n        \"\"\"\n        if self._from_device_acls is None:\n            self._from_device_acls = self._resolve_policy_acls(\n                self.mud.from_device_policy\n            )\n        return self._from_device_acls\n\n    def get_to_device_acls(self) -&gt; list[AccessControlList]:\n        \"\"\"\n        Get all ACLs referenced by the to-device policy.\n\n        Returns:\n            List of ACLs for inbound traffic control.\n        \"\"\"\n        if self._to_device_acls is None:\n            self._to_device_acls = self._resolve_policy_acls(\n                self.mud.to_device_policy\n            )\n        return self._to_device_acls\n\n    def _resolve_policy_acls(self, policy: PolicyReference) -&gt; list[AccessControlList]:\n        \"\"\"Resolve ACL references in a policy to actual ACL objects.\"\"\"\n        resolved: list[AccessControlList] = []\n        for acl_name in policy.acl_names:\n            acl = self.get_acl(acl_name)\n            if acl:\n                resolved.append(acl)\n        return resolved\n\n    def get_acl_direction(self, acl_name: str) -&gt; str | None:\n        \"\"\"\n        Determine which policy direction an ACL belongs to.\n\n        Args:\n            acl_name: The name of the ACL.\n\n        Returns:\n            'from' for from-device, 'to' for to-device, None if not found.\n        \"\"\"\n        if acl_name in self.mud.from_device_policy.acl_names:\n            return \"from\"\n        if acl_name in self.mud.to_device_policy.acl_names:\n            return \"to\"\n        return None\n\n    def print_rules(self) -&gt; str:\n        \"\"\"\n        Generate a human-readable representation of all rules.\n\n        Returns:\n            Multi-line string with all rules organized by direction.\n        \"\"\"\n        lines: list[str] = [\n            \"=\" * 60,\n            f\"MUD Profile: {self.mud.systeminfo or 'Unknown Device'}\",\n            f\"URL: {self.url}\",\n            f\"Version: {self.version}\",\n            f\"Last Update: {self.last_update}\",\n            f\"Supported: {self.is_supported}\",\n            \"=\" * 60,\n            \"\",\n            \"### FROM-DEVICE POLICY (Outbound) ###\",\n            \"\",\n        ]\n\n        for acl in self.get_from_device_acls():\n            lines.append(acl.print_rules(\"from\"))\n            lines.append(\"\")\n\n        lines.extend([\n            \"### TO-DEVICE POLICY (Inbound) ###\",\n            \"\",\n        ])\n\n        for acl in self.get_to_device_acls():\n            lines.append(acl.print_rules(\"to\"))\n            lines.append(\"\")\n\n        return \"\\n\".join(lines)\n\n    def get_all_dns_names(self) -&gt; set[str]:\n        \"\"\"\n        Get all DNS names referenced in the profile.\n\n        Returns:\n            Set of all DNS names used in match conditions.\n        \"\"\"\n        dns_names: set[str] = set()\n\n        for acl in self.acls.acl:\n            for entry in acl.entries:\n                names = entry.matches.get_dns_names()\n                if names[\"src\"]:\n                    dns_names.add(names[\"src\"])\n                if names[\"dst\"]:\n                    dns_names.add(names[\"dst\"])\n\n        return dns_names\n\n    def get_all_ports(self) -&gt; dict[str, set[int]]:\n        \"\"\"\n        Get all ports referenced in the profile.\n\n        Returns:\n            Dictionary with 'tcp' and 'udp' keys containing port sets.\n        \"\"\"\n        ports: dict[str, set[int]] = {\"tcp\": set(), \"udp\": set()}\n\n        for acl in self.acls.acl:\n            for entry in acl.entries:\n                if entry.matches.tcp:\n                    if entry.matches.tcp.src_port:\n                        ports[\"tcp\"].add(entry.matches.tcp.src_port.port)\n                    if entry.matches.tcp.dst_port:\n                        ports[\"tcp\"].add(entry.matches.tcp.dst_port.port)\n                if entry.matches.udp:\n                    if entry.matches.udp.src_port:\n                        ports[\"udp\"].add(entry.matches.udp.src_port.port)\n                    if entry.matches.udp.dst_port:\n                        ports[\"udp\"].add(entry.matches.udp.dst_port.port)\n\n        return ports\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert the profile to a dictionary representation.\"\"\"\n        return {\n            \"ietf-mud:mud\": self.mud.model_dump(by_alias=True, exclude_none=True),\n            \"ietf-access-control-list:access-lists\": {\n                \"acl\": [acl.to_dict() for acl in self.acls.acl]\n            },\n        }\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.cache_validity","title":"<code>cache_validity</code>  <code>property</code>","text":"<p>Get the cache validity in hours.</p>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.is_supported","title":"<code>is_supported</code>  <code>property</code>","text":"<p>Check if the device is still supported.</p>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.last_update","title":"<code>last_update</code>  <code>property</code>","text":"<p>Get the last update timestamp.</p>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.systeminfo","title":"<code>systeminfo</code>  <code>property</code>","text":"<p>Get the system info string.</p>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.url","title":"<code>url</code>  <code>property</code>","text":"<p>Get the MUD URL.</p>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.version","title":"<code>version</code>  <code>property</code>","text":"<p>Get the MUD version.</p>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Create a MUDProfile from JSON data.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>@classmethod\ndef from_json(cls, data: dict[str, Any]) -&gt; \"MUDProfile\":\n    \"\"\"Create a MUDProfile from JSON data.\"\"\"\n    # Parse ACLs\n    acls_data = data.get(\"ietf-access-control-list:access-lists\", {})\n    acl_list = [AccessControlList.from_json(acl) for acl in acls_data.get(\"acl\", [])]\n\n    # Parse MUD container\n    mud_data = data.get(\"ietf-mud:mud\", {})\n\n    return cls(\n        mud=MUDContainer(**mud_data),\n        acls=ACLsContainer(acl=acl_list),\n    )\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.get_acl","title":"<code>get_acl(name)</code>","text":"<p>Get an ACL by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The ACL name to look up.</p> required <p>Returns:</p> Type Description <code>AccessControlList | None</code> <p>The ACL if found, None otherwise.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>def get_acl(self, name: str) -&gt; AccessControlList | None:\n    \"\"\"\n    Get an ACL by name.\n\n    Args:\n        name: The ACL name to look up.\n\n    Returns:\n        The ACL if found, None otherwise.\n    \"\"\"\n    for acl in self.acls.acl:\n        if acl.name == name:\n            return acl\n    return None\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.get_acl_direction","title":"<code>get_acl_direction(acl_name)</code>","text":"<p>Determine which policy direction an ACL belongs to.</p> <p>Parameters:</p> Name Type Description Default <code>acl_name</code> <code>str</code> <p>The name of the ACL.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>'from' for from-device, 'to' for to-device, None if not found.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>def get_acl_direction(self, acl_name: str) -&gt; str | None:\n    \"\"\"\n    Determine which policy direction an ACL belongs to.\n\n    Args:\n        acl_name: The name of the ACL.\n\n    Returns:\n        'from' for from-device, 'to' for to-device, None if not found.\n    \"\"\"\n    if acl_name in self.mud.from_device_policy.acl_names:\n        return \"from\"\n    if acl_name in self.mud.to_device_policy.acl_names:\n        return \"to\"\n    return None\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.get_all_dns_names","title":"<code>get_all_dns_names()</code>","text":"<p>Get all DNS names referenced in the profile.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of all DNS names used in match conditions.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>def get_all_dns_names(self) -&gt; set[str]:\n    \"\"\"\n    Get all DNS names referenced in the profile.\n\n    Returns:\n        Set of all DNS names used in match conditions.\n    \"\"\"\n    dns_names: set[str] = set()\n\n    for acl in self.acls.acl:\n        for entry in acl.entries:\n            names = entry.matches.get_dns_names()\n            if names[\"src\"]:\n                dns_names.add(names[\"src\"])\n            if names[\"dst\"]:\n                dns_names.add(names[\"dst\"])\n\n    return dns_names\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.get_all_ports","title":"<code>get_all_ports()</code>","text":"<p>Get all ports referenced in the profile.</p> <p>Returns:</p> Type Description <code>dict[str, set[int]]</code> <p>Dictionary with 'tcp' and 'udp' keys containing port sets.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>def get_all_ports(self) -&gt; dict[str, set[int]]:\n    \"\"\"\n    Get all ports referenced in the profile.\n\n    Returns:\n        Dictionary with 'tcp' and 'udp' keys containing port sets.\n    \"\"\"\n    ports: dict[str, set[int]] = {\"tcp\": set(), \"udp\": set()}\n\n    for acl in self.acls.acl:\n        for entry in acl.entries:\n            if entry.matches.tcp:\n                if entry.matches.tcp.src_port:\n                    ports[\"tcp\"].add(entry.matches.tcp.src_port.port)\n                if entry.matches.tcp.dst_port:\n                    ports[\"tcp\"].add(entry.matches.tcp.dst_port.port)\n            if entry.matches.udp:\n                if entry.matches.udp.src_port:\n                    ports[\"udp\"].add(entry.matches.udp.src_port.port)\n                if entry.matches.udp.dst_port:\n                    ports[\"udp\"].add(entry.matches.udp.dst_port.port)\n\n    return ports\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.get_from_device_acls","title":"<code>get_from_device_acls()</code>","text":"<p>Get all ACLs referenced by the from-device policy.</p> <p>Returns:</p> Type Description <code>list[AccessControlList]</code> <p>List of ACLs for outbound traffic control.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>def get_from_device_acls(self) -&gt; list[AccessControlList]:\n    \"\"\"\n    Get all ACLs referenced by the from-device policy.\n\n    Returns:\n        List of ACLs for outbound traffic control.\n    \"\"\"\n    if self._from_device_acls is None:\n        self._from_device_acls = self._resolve_policy_acls(\n            self.mud.from_device_policy\n        )\n    return self._from_device_acls\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.get_to_device_acls","title":"<code>get_to_device_acls()</code>","text":"<p>Get all ACLs referenced by the to-device policy.</p> <p>Returns:</p> Type Description <code>list[AccessControlList]</code> <p>List of ACLs for inbound traffic control.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>def get_to_device_acls(self) -&gt; list[AccessControlList]:\n    \"\"\"\n    Get all ACLs referenced by the to-device policy.\n\n    Returns:\n        List of ACLs for inbound traffic control.\n    \"\"\"\n    if self._to_device_acls is None:\n        self._to_device_acls = self._resolve_policy_acls(\n            self.mud.to_device_policy\n        )\n    return self._to_device_acls\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.print_rules","title":"<code>print_rules()</code>","text":"<p>Generate a human-readable representation of all rules.</p> <p>Returns:</p> Type Description <code>str</code> <p>Multi-line string with all rules organized by direction.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>def print_rules(self) -&gt; str:\n    \"\"\"\n    Generate a human-readable representation of all rules.\n\n    Returns:\n        Multi-line string with all rules organized by direction.\n    \"\"\"\n    lines: list[str] = [\n        \"=\" * 60,\n        f\"MUD Profile: {self.mud.systeminfo or 'Unknown Device'}\",\n        f\"URL: {self.url}\",\n        f\"Version: {self.version}\",\n        f\"Last Update: {self.last_update}\",\n        f\"Supported: {self.is_supported}\",\n        \"=\" * 60,\n        \"\",\n        \"### FROM-DEVICE POLICY (Outbound) ###\",\n        \"\",\n    ]\n\n    for acl in self.get_from_device_acls():\n        lines.append(acl.print_rules(\"from\"))\n        lines.append(\"\")\n\n    lines.extend([\n        \"### TO-DEVICE POLICY (Inbound) ###\",\n        \"\",\n    ])\n\n    for acl in self.get_to_device_acls():\n        lines.append(acl.print_rules(\"to\"))\n        lines.append(\"\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDProfile.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the profile to a dictionary representation.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the profile to a dictionary representation.\"\"\"\n    return {\n        \"ietf-mud:mud\": self.mud.model_dump(by_alias=True, exclude_none=True),\n        \"ietf-access-control-list:access-lists\": {\n            \"acl\": [acl.to_dict() for acl in self.acls.acl]\n        },\n    }\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDContainer","title":"<code>mudparser.models.mud.MUDContainer</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The main MUD container with metadata and policy references.</p> <p>This represents the 'ietf-mud:mud' container in a MUD profile, containing device metadata and references to access control policies.</p> <p>Attributes:</p> Name Type Description <code>mud_version</code> <code>int</code> <p>MUD specification version (currently 1).</p> <code>mud_url</code> <code>HttpUrl</code> <p>The canonical URL for this MUD file.</p> <code>last_update</code> <code>datetime</code> <p>Timestamp of last modification.</p> <code>cache_validity</code> <code>int</code> <p>Hours before the MUD file should be refreshed (1-168).</p> <code>is_supported</code> <code>bool</code> <p>Whether the manufacturer still supports this device.</p> <code>systeminfo</code> <code>str | None</code> <p>Human-readable device description (max 60 chars).</p> <code>mfg_name</code> <code>str | None</code> <p>Manufacturer name.</p> <code>model_name</code> <code>str | None</code> <p>Device model name.</p> <code>firmware_rev</code> <code>str | None</code> <p>Firmware revision.</p> <code>software_rev</code> <code>str | None</code> <p>Software revision.</p> <code>documentation</code> <code>HttpUrl | None</code> <p>URL to device documentation.</p> <code>extensions</code> <code>list[str]</code> <p>List of extension names used in this profile.</p> <code>from_device_policy</code> <code>PolicyReference</code> <p>Policy for outbound (device-initiated) traffic.</p> <code>to_device_policy</code> <code>PolicyReference</code> <p>Policy for inbound (to-device) traffic.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>class MUDContainer(BaseModel):\n    \"\"\"\n    The main MUD container with metadata and policy references.\n\n    This represents the 'ietf-mud:mud' container in a MUD profile,\n    containing device metadata and references to access control policies.\n\n    Attributes:\n        mud_version: MUD specification version (currently 1).\n        mud_url: The canonical URL for this MUD file.\n        last_update: Timestamp of last modification.\n        cache_validity: Hours before the MUD file should be refreshed (1-168).\n        is_supported: Whether the manufacturer still supports this device.\n        systeminfo: Human-readable device description (max 60 chars).\n        mfg_name: Manufacturer name.\n        model_name: Device model name.\n        firmware_rev: Firmware revision.\n        software_rev: Software revision.\n        documentation: URL to device documentation.\n        extensions: List of extension names used in this profile.\n        from_device_policy: Policy for outbound (device-initiated) traffic.\n        to_device_policy: Policy for inbound (to-device) traffic.\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    mud_version: int = Field(alias=\"mud-version\", ge=1)\n    mud_url: HttpUrl = Field(alias=\"mud-url\")\n    last_update: datetime = Field(alias=\"last-update\")\n    cache_validity: int = Field(default=48, alias=\"cache-validity\", ge=1, le=168)\n    is_supported: bool = Field(alias=\"is-supported\")\n    systeminfo: str | None = Field(None, max_length=60)\n    mfg_name: str | None = Field(None, alias=\"mfg-name\")\n    model_name: str | None = Field(None, alias=\"model-name\")\n    firmware_rev: str | None = Field(None, alias=\"firmware-rev\")\n    software_rev: str | None = Field(None, alias=\"software-rev\")\n    documentation: HttpUrl | None = None\n    extensions: list[str] = Field(default_factory=list)\n    from_device_policy: PolicyReference = Field(alias=\"from-device-policy\")\n    to_device_policy: PolicyReference = Field(alias=\"to-device-policy\")\n\n    @field_validator(\"mud_version\")\n    @classmethod\n    def validate_version(cls, v: int) -&gt; int:\n        \"\"\"Validate that the MUD version is supported.\"\"\"\n        if v != 1:\n            raise ValueError(f\"Unsupported MUD version: {v}. Only version 1 is supported.\")\n        return v\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.mud.MUDContainer.validate_version","title":"<code>validate_version(v)</code>  <code>classmethod</code>","text":"<p>Validate that the MUD version is supported.</p> Source code in <code>src/mudparser/models/mud.py</code> <pre><code>@field_validator(\"mud_version\")\n@classmethod\ndef validate_version(cls, v: int) -&gt; int:\n    \"\"\"Validate that the MUD version is supported.\"\"\"\n    if v != 1:\n        raise ValueError(f\"Unsupported MUD version: {v}. Only version 1 is supported.\")\n    return v\n</code></pre>"},{"location":"api-reference/models/#access-control-lists","title":"Access Control Lists","text":""},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList","title":"<code>mudparser.models.acl.AccessControlList</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An Access Control List containing multiple entries.</p> <p>Each ACL has a unique name, a type indicating what kind of traffic it applies to, and a list of ACEs (Access Control Entries) that define the actual rules.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for this ACL.</p> <code>acl_type</code> <code>ACLType</code> <p>The type of ACL (IPv4, IPv6, Ethernet, etc.).</p> <code>aces</code> <code>ACEs</code> <p>Container holding the list of ACEs.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>class AccessControlList(BaseModel):\n    \"\"\"\n    An Access Control List containing multiple entries.\n\n    Each ACL has a unique name, a type indicating what kind of traffic\n    it applies to, and a list of ACEs (Access Control Entries) that\n    define the actual rules.\n\n    Attributes:\n        name: Unique identifier for this ACL.\n        acl_type: The type of ACL (IPv4, IPv6, Ethernet, etc.).\n        aces: Container holding the list of ACEs.\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    name: str\n    acl_type: ACLType = Field(alias=\"type\")\n    aces: ACEs\n\n    @classmethod\n    def from_json(cls, data: dict[str, Any]) -&gt; \"AccessControlList\":\n        \"\"\"Create an ACL from JSON data.\"\"\"\n        aces_data = data.get(\"aces\", {}).get(\"ace\", [])\n        entries = [AccessControlEntry.from_json(ace) for ace in aces_data]\n\n        return cls(\n            name=data[\"name\"],\n            acl_type=ACLType(data[\"type\"]),\n            aces=ACEs(ace=entries),\n        )\n\n    @property\n    def entries(self) -&gt; list[AccessControlEntry]:\n        \"\"\"Get the list of ACEs in this ACL.\"\"\"\n        return self.aces.ace\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of entries in this ACL.\"\"\"\n        return len(self.entries)\n\n    def __iter__(self) -&gt; Iterator[AccessControlEntry]:\n        \"\"\"Iterate over ACEs in this ACL.\"\"\"\n        return iter(self.entries)\n\n    def __getitem__(self, key: str | int) -&gt; AccessControlEntry:\n        \"\"\"Get an ACE by name or index.\"\"\"\n        if isinstance(key, int):\n            return self.entries[key]\n        for entry in self.entries:\n            if entry.name == key:\n                return entry\n        raise KeyError(f\"ACE '{key}' not found in ACL '{self.name}'\")\n\n    def get_entry(self, name: str) -&gt; AccessControlEntry | None:\n        \"\"\"Get an ACE by name, returning None if not found.\"\"\"\n        for entry in self.entries:\n            if entry.name == name:\n                return entry\n        return None\n\n    def is_ipv4(self) -&gt; bool:\n        \"\"\"Check if this is an IPv4 ACL.\"\"\"\n        return self.acl_type == ACLType.IPV4\n\n    def is_ipv6(self) -&gt; bool:\n        \"\"\"Check if this is an IPv6 ACL.\"\"\"\n        return self.acl_type == ACLType.IPV6\n\n    def is_ethernet(self) -&gt; bool:\n        \"\"\"Check if this is an Ethernet ACL.\"\"\"\n        return self.acl_type == ACLType.ETHERNET\n\n    def print_rules(self, direction: str = \"from\") -&gt; str:\n        \"\"\"\n        Generate a human-readable representation of all rules.\n\n        Args:\n            direction: Traffic direction ('from' or 'to' device).\n\n        Returns:\n            Multi-line string with all rules.\n        \"\"\"\n        lines: list[str] = [\n            f\"##### ACL::{self.name}::START #####\",\n            f\"Type: {self.acl_type.value}\",\n            \"\",\n        ]\n\n        for entry in self.entries:\n            lines.append(f\"  {entry.get_description(direction)}\")\n\n        lines.extend([\n            \"\",\n            \"(implicit deny all)\",\n            f\"##### ACL::{self.name}::END #####\",\n        ])\n\n        return \"\\n\".join(lines)\n\n    def get_accept_rules(self) -&gt; list[AccessControlEntry]:\n        \"\"\"Get all ACEs that accept traffic.\"\"\"\n        return [entry for entry in self.entries if entry.is_accept()]\n\n    def get_deny_rules(self) -&gt; list[AccessControlEntry]:\n        \"\"\"Get all ACEs that deny traffic.\"\"\"\n        return [entry for entry in self.entries if entry.is_deny()]\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert ACL to dictionary representation.\"\"\"\n        return {\n            \"name\": self.name,\n            \"type\": self.acl_type.value,\n            \"aces\": {\n                \"ace\": [entry.to_dict() for entry in self.entries]\n            },\n        }\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.entries","title":"<code>entries</code>  <code>property</code>","text":"<p>Get the list of ACEs in this ACL.</p>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get an ACE by name or index.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def __getitem__(self, key: str | int) -&gt; AccessControlEntry:\n    \"\"\"Get an ACE by name or index.\"\"\"\n    if isinstance(key, int):\n        return self.entries[key]\n    for entry in self.entries:\n        if entry.name == key:\n            return entry\n    raise KeyError(f\"ACE '{key}' not found in ACL '{self.name}'\")\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over ACEs in this ACL.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def __iter__(self) -&gt; Iterator[AccessControlEntry]:\n    \"\"\"Iterate over ACEs in this ACL.\"\"\"\n    return iter(self.entries)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of entries in this ACL.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of entries in this ACL.\"\"\"\n    return len(self.entries)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Create an ACL from JSON data.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>@classmethod\ndef from_json(cls, data: dict[str, Any]) -&gt; \"AccessControlList\":\n    \"\"\"Create an ACL from JSON data.\"\"\"\n    aces_data = data.get(\"aces\", {}).get(\"ace\", [])\n    entries = [AccessControlEntry.from_json(ace) for ace in aces_data]\n\n    return cls(\n        name=data[\"name\"],\n        acl_type=ACLType(data[\"type\"]),\n        aces=ACEs(ace=entries),\n    )\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.get_accept_rules","title":"<code>get_accept_rules()</code>","text":"<p>Get all ACEs that accept traffic.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def get_accept_rules(self) -&gt; list[AccessControlEntry]:\n    \"\"\"Get all ACEs that accept traffic.\"\"\"\n    return [entry for entry in self.entries if entry.is_accept()]\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.get_deny_rules","title":"<code>get_deny_rules()</code>","text":"<p>Get all ACEs that deny traffic.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def get_deny_rules(self) -&gt; list[AccessControlEntry]:\n    \"\"\"Get all ACEs that deny traffic.\"\"\"\n    return [entry for entry in self.entries if entry.is_deny()]\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.get_entry","title":"<code>get_entry(name)</code>","text":"<p>Get an ACE by name, returning None if not found.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def get_entry(self, name: str) -&gt; AccessControlEntry | None:\n    \"\"\"Get an ACE by name, returning None if not found.\"\"\"\n    for entry in self.entries:\n        if entry.name == name:\n            return entry\n    return None\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.is_ethernet","title":"<code>is_ethernet()</code>","text":"<p>Check if this is an Ethernet ACL.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def is_ethernet(self) -&gt; bool:\n    \"\"\"Check if this is an Ethernet ACL.\"\"\"\n    return self.acl_type == ACLType.ETHERNET\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.is_ipv4","title":"<code>is_ipv4()</code>","text":"<p>Check if this is an IPv4 ACL.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def is_ipv4(self) -&gt; bool:\n    \"\"\"Check if this is an IPv4 ACL.\"\"\"\n    return self.acl_type == ACLType.IPV4\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.is_ipv6","title":"<code>is_ipv6()</code>","text":"<p>Check if this is an IPv6 ACL.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def is_ipv6(self) -&gt; bool:\n    \"\"\"Check if this is an IPv6 ACL.\"\"\"\n    return self.acl_type == ACLType.IPV6\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.print_rules","title":"<code>print_rules(direction='from')</code>","text":"<p>Generate a human-readable representation of all rules.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>Traffic direction ('from' or 'to' device).</p> <code>'from'</code> <p>Returns:</p> Type Description <code>str</code> <p>Multi-line string with all rules.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def print_rules(self, direction: str = \"from\") -&gt; str:\n    \"\"\"\n    Generate a human-readable representation of all rules.\n\n    Args:\n        direction: Traffic direction ('from' or 'to' device).\n\n    Returns:\n        Multi-line string with all rules.\n    \"\"\"\n    lines: list[str] = [\n        f\"##### ACL::{self.name}::START #####\",\n        f\"Type: {self.acl_type.value}\",\n        \"\",\n    ]\n\n    for entry in self.entries:\n        lines.append(f\"  {entry.get_description(direction)}\")\n\n    lines.extend([\n        \"\",\n        \"(implicit deny all)\",\n        f\"##### ACL::{self.name}::END #####\",\n    ])\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.acl.AccessControlList.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert ACL to dictionary representation.</p> Source code in <code>src/mudparser/models/acl.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert ACL to dictionary representation.\"\"\"\n    return {\n        \"name\": self.name,\n        \"type\": self.acl_type.value,\n        \"aces\": {\n            \"ace\": [entry.to_dict() for entry in self.entries]\n        },\n    }\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.ace.AccessControlEntry","title":"<code>mudparser.models.ace.AccessControlEntry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single Access Control Entry (ACE).</p> <p>An ACE defines a rule consisting of: - Match conditions (what traffic to match) - Actions (what to do with matched traffic)</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for this ACE within its ACL.</p> <code>matches</code> <code>ACEMatches</code> <p>The match conditions for this entry.</p> <code>actions</code> <code>ACEActions</code> <p>The actions to take when matched.</p> <code>statistics</code> <code>dict[str, Any] | None</code> <p>Optional statistics about rule hits (read-only).</p> Source code in <code>src/mudparser/models/ace.py</code> <pre><code>class AccessControlEntry(BaseModel):\n    \"\"\"\n    A single Access Control Entry (ACE).\n\n    An ACE defines a rule consisting of:\n    - Match conditions (what traffic to match)\n    - Actions (what to do with matched traffic)\n\n    Attributes:\n        name: Unique identifier for this ACE within its ACL.\n        matches: The match conditions for this entry.\n        actions: The actions to take when matched.\n        statistics: Optional statistics about rule hits (read-only).\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    name: str\n    matches: ACEMatches\n    actions: ACEActions\n    statistics: dict[str, Any] | None = None\n\n    @classmethod\n    def from_json(cls, data: dict[str, Any]) -&gt; \"AccessControlEntry\":\n        \"\"\"Create an ACE from JSON data.\"\"\"\n        return cls(\n            name=data[\"name\"],\n            matches=ACEMatches.from_json(data.get(\"matches\", {})),\n            actions=ACEActions(**data.get(\"actions\", {})),\n            statistics=data.get(\"statistics\"),\n        )\n\n    def is_accept(self) -&gt; bool:\n        \"\"\"Check if this ACE allows traffic.\"\"\"\n        return self.actions.forwarding == ForwardingAction.ACCEPT\n\n    def is_deny(self) -&gt; bool:\n        \"\"\"Check if this ACE denies traffic.\"\"\"\n        return self.actions.forwarding in (ForwardingAction.DROP, ForwardingAction.REJECT)\n\n    def get_description(self, direction: str = \"from\") -&gt; str:\n        \"\"\"\n        Generate a human-readable description of this ACE.\n\n        Args:\n            direction: Traffic direction ('from' or 'to' device).\n\n        Returns:\n            Human-readable rule description.\n        \"\"\"\n        parts: list[str] = []\n\n        # Action\n        action = \"ALLOW\" if self.is_accept() else \"DENY\"\n        parts.append(f\"[{direction.upper()}] {action}\")\n\n        # Protocol\n        protocol = self._get_protocol_name()\n        if protocol:\n            parts.append(protocol)\n\n        # DNS names\n        dns_names = self.matches.get_dns_names()\n        if direction == \"from\":\n            if dns_names[\"dst\"]:\n                parts.append(f\"to {dns_names['dst']}\")\n        else:\n            if dns_names[\"src\"]:\n                parts.append(f\"from {dns_names['src']}\")\n\n        # Ports\n        port_info = self._get_port_info(direction)\n        if port_info:\n            parts.append(port_info)\n\n        # MUD matches\n        if self.matches.mud:\n            mud_type = self.matches.mud.get_match_type()\n            if mud_type:\n                parts.append(f\"({mud_type})\")\n\n        # Ethernet\n        if self.matches.eth and self.matches.eth.ethertype:\n            parts.append(f\"ethertype {self.matches.eth.ethertype}\")\n\n        return \" \".join(parts)\n\n    def _get_protocol_name(self) -&gt; str | None:\n        \"\"\"Get the protocol name from matches.\"\"\"\n        proto = self.matches.get_protocol()\n        if proto is not None:\n            protocol_map = {\n                1: \"ICMP\",\n                6: \"TCP\",\n                17: \"UDP\",\n                58: \"ICMPv6\",\n            }\n            return protocol_map.get(proto, f\"proto:{proto}\")\n\n        # Check for L4 matches\n        if self.matches.tcp:\n            return \"TCP\"\n        if self.matches.udp:\n            return \"UDP\"\n        if self.matches.icmp:\n            return \"ICMP\"\n\n        return None\n\n    def _get_port_info(self, direction: str) -&gt; str | None:\n        \"\"\"Get port information from matches.\"\"\"\n        if self.matches.tcp:\n            if direction == \"from\" and self.matches.tcp.dst_port:\n                return f\"port {self.matches.tcp.dst_port}\"\n            elif direction == \"to\" and self.matches.tcp.src_port:\n                return f\"port {self.matches.tcp.src_port}\"\n\n        if self.matches.udp:\n            if direction == \"from\" and self.matches.udp.dst_port:\n                return f\"port {self.matches.udp.dst_port}\"\n            elif direction == \"to\" and self.matches.udp.src_port:\n                return f\"port {self.matches.udp.src_port}\"\n\n        return None\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert ACE to dictionary representation.\"\"\"\n        return {\n            \"name\": self.name,\n            \"matches\": self.matches.model_dump(by_alias=True, exclude_none=True),\n            \"actions\": self.actions.model_dump(by_alias=True, exclude_none=True),\n        }\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.ace.AccessControlEntry.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Create an ACE from JSON data.</p> Source code in <code>src/mudparser/models/ace.py</code> <pre><code>@classmethod\ndef from_json(cls, data: dict[str, Any]) -&gt; \"AccessControlEntry\":\n    \"\"\"Create an ACE from JSON data.\"\"\"\n    return cls(\n        name=data[\"name\"],\n        matches=ACEMatches.from_json(data.get(\"matches\", {})),\n        actions=ACEActions(**data.get(\"actions\", {})),\n        statistics=data.get(\"statistics\"),\n    )\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.ace.AccessControlEntry.get_description","title":"<code>get_description(direction='from')</code>","text":"<p>Generate a human-readable description of this ACE.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>Traffic direction ('from' or 'to' device).</p> <code>'from'</code> <p>Returns:</p> Type Description <code>str</code> <p>Human-readable rule description.</p> Source code in <code>src/mudparser/models/ace.py</code> <pre><code>def get_description(self, direction: str = \"from\") -&gt; str:\n    \"\"\"\n    Generate a human-readable description of this ACE.\n\n    Args:\n        direction: Traffic direction ('from' or 'to' device).\n\n    Returns:\n        Human-readable rule description.\n    \"\"\"\n    parts: list[str] = []\n\n    # Action\n    action = \"ALLOW\" if self.is_accept() else \"DENY\"\n    parts.append(f\"[{direction.upper()}] {action}\")\n\n    # Protocol\n    protocol = self._get_protocol_name()\n    if protocol:\n        parts.append(protocol)\n\n    # DNS names\n    dns_names = self.matches.get_dns_names()\n    if direction == \"from\":\n        if dns_names[\"dst\"]:\n            parts.append(f\"to {dns_names['dst']}\")\n    else:\n        if dns_names[\"src\"]:\n            parts.append(f\"from {dns_names['src']}\")\n\n    # Ports\n    port_info = self._get_port_info(direction)\n    if port_info:\n        parts.append(port_info)\n\n    # MUD matches\n    if self.matches.mud:\n        mud_type = self.matches.mud.get_match_type()\n        if mud_type:\n            parts.append(f\"({mud_type})\")\n\n    # Ethernet\n    if self.matches.eth and self.matches.eth.ethertype:\n        parts.append(f\"ethertype {self.matches.eth.ethertype}\")\n\n    return \" \".join(parts)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.ace.AccessControlEntry.is_accept","title":"<code>is_accept()</code>","text":"<p>Check if this ACE allows traffic.</p> Source code in <code>src/mudparser/models/ace.py</code> <pre><code>def is_accept(self) -&gt; bool:\n    \"\"\"Check if this ACE allows traffic.\"\"\"\n    return self.actions.forwarding == ForwardingAction.ACCEPT\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.ace.AccessControlEntry.is_deny","title":"<code>is_deny()</code>","text":"<p>Check if this ACE denies traffic.</p> Source code in <code>src/mudparser/models/ace.py</code> <pre><code>def is_deny(self) -&gt; bool:\n    \"\"\"Check if this ACE denies traffic.\"\"\"\n    return self.actions.forwarding in (ForwardingAction.DROP, ForwardingAction.REJECT)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.ace.AccessControlEntry.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert ACE to dictionary representation.</p> Source code in <code>src/mudparser/models/ace.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert ACE to dictionary representation.\"\"\"\n    return {\n        \"name\": self.name,\n        \"matches\": self.matches.model_dump(by_alias=True, exclude_none=True),\n        \"actions\": self.actions.model_dump(by_alias=True, exclude_none=True),\n    }\n</code></pre>"},{"location":"api-reference/models/#match-types","title":"Match Types","text":""},{"location":"api-reference/models/#mudparser.models.matches.ACEMatches","title":"<code>mudparser.models.matches.ACEMatches</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Container for all match types in an ACE.</p> <p>An ACE can have multiple match conditions that are ANDed together. All specified conditions must match for the ACE to apply.</p> <p>Attributes:</p> Name Type Description <code>ipv4</code> <code>IPv4Match | None</code> <p>IPv4 header match conditions.</p> <code>ipv6</code> <code>IPv6Match | None</code> <p>IPv6 header match conditions.</p> <code>tcp</code> <code>TCPMatch | None</code> <p>TCP header match conditions.</p> <code>udp</code> <code>UDPMatch | None</code> <p>UDP header match conditions.</p> <code>icmp</code> <code>ICMPMatch | None</code> <p>ICMP match conditions.</p> <code>eth</code> <code>EthernetMatch | None</code> <p>Ethernet frame match conditions.</p> <code>mud</code> <code>MUDMatch | None</code> <p>MUD-specific abstract match conditions.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>class ACEMatches(BaseModel):\n    \"\"\"\n    Container for all match types in an ACE.\n\n    An ACE can have multiple match conditions that are ANDed together.\n    All specified conditions must match for the ACE to apply.\n\n    Attributes:\n        ipv4: IPv4 header match conditions.\n        ipv6: IPv6 header match conditions.\n        tcp: TCP header match conditions.\n        udp: UDP header match conditions.\n        icmp: ICMP match conditions.\n        eth: Ethernet frame match conditions.\n        mud: MUD-specific abstract match conditions.\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    ipv4: IPv4Match | None = None\n    ipv6: IPv6Match | None = None\n    tcp: TCPMatch | None = None\n    udp: UDPMatch | None = None\n    icmp: ICMPMatch | None = None\n    eth: EthernetMatch | None = None\n    mud: MUDMatch | None = Field(None, alias=\"ietf-mud:mud\")\n\n    @classmethod\n    def from_json(cls, data: dict[str, Any]) -&gt; \"ACEMatches\":\n        \"\"\"Create ACEMatches from JSON data with proper type handling.\"\"\"\n        processed: dict[str, Any] = {}\n\n        for key, value in data.items():\n            if value is None:\n                continue\n\n            match key:\n                case \"ipv4\":\n                    processed[\"ipv4\"] = IPv4Match(**value)\n                case \"ipv6\":\n                    processed[\"ipv6\"] = IPv6Match(**value)\n                case \"tcp\":\n                    processed[\"tcp\"] = TCPMatch.from_json(value)\n                case \"udp\":\n                    processed[\"udp\"] = UDPMatch.from_json(value)\n                case \"icmp\":\n                    processed[\"icmp\"] = ICMPMatch(**value)\n                case \"eth\":\n                    processed[\"eth\"] = EthernetMatch(**value)\n                case \"ietf-mud:mud\":\n                    processed[\"mud\"] = MUDMatch(**value)\n                case _:\n                    # Handle unknown match types gracefully\n                    pass\n\n        return cls(**processed)\n\n    def has_matches(self) -&gt; bool:\n        \"\"\"Check if any match conditions are specified.\"\"\"\n        return any(\n            [self.ipv4, self.ipv6, self.tcp, self.udp, self.icmp, self.eth, self.mud]\n        )\n\n    def get_protocol(self) -&gt; int | None:\n        \"\"\"Get the IP protocol number from IPv4/IPv6 matches.\"\"\"\n        if self.ipv4 and self.ipv4.protocol:\n            return self.ipv4.protocol\n        if self.ipv6 and self.ipv6.next_header:\n            return self.ipv6.next_header\n        return None\n\n    def get_dns_names(self) -&gt; dict[str, str | None]:\n        \"\"\"Get source and destination DNS names from matches.\"\"\"\n        result: dict[str, str | None] = {\"src\": None, \"dst\": None}\n        for ip_match in (self.ipv4, self.ipv6):\n            if ip_match:\n                if ip_match.src_dnsname:\n                    result[\"src\"] = ip_match.src_dnsname\n                if ip_match.dst_dnsname:\n                    result[\"dst\"] = ip_match.dst_dnsname\n        return result\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.ACEMatches.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Create ACEMatches from JSON data with proper type handling.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>@classmethod\ndef from_json(cls, data: dict[str, Any]) -&gt; \"ACEMatches\":\n    \"\"\"Create ACEMatches from JSON data with proper type handling.\"\"\"\n    processed: dict[str, Any] = {}\n\n    for key, value in data.items():\n        if value is None:\n            continue\n\n        match key:\n            case \"ipv4\":\n                processed[\"ipv4\"] = IPv4Match(**value)\n            case \"ipv6\":\n                processed[\"ipv6\"] = IPv6Match(**value)\n            case \"tcp\":\n                processed[\"tcp\"] = TCPMatch.from_json(value)\n            case \"udp\":\n                processed[\"udp\"] = UDPMatch.from_json(value)\n            case \"icmp\":\n                processed[\"icmp\"] = ICMPMatch(**value)\n            case \"eth\":\n                processed[\"eth\"] = EthernetMatch(**value)\n            case \"ietf-mud:mud\":\n                processed[\"mud\"] = MUDMatch(**value)\n            case _:\n                # Handle unknown match types gracefully\n                pass\n\n    return cls(**processed)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.ACEMatches.get_dns_names","title":"<code>get_dns_names()</code>","text":"<p>Get source and destination DNS names from matches.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>def get_dns_names(self) -&gt; dict[str, str | None]:\n    \"\"\"Get source and destination DNS names from matches.\"\"\"\n    result: dict[str, str | None] = {\"src\": None, \"dst\": None}\n    for ip_match in (self.ipv4, self.ipv6):\n        if ip_match:\n            if ip_match.src_dnsname:\n                result[\"src\"] = ip_match.src_dnsname\n            if ip_match.dst_dnsname:\n                result[\"dst\"] = ip_match.dst_dnsname\n    return result\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.ACEMatches.get_protocol","title":"<code>get_protocol()</code>","text":"<p>Get the IP protocol number from IPv4/IPv6 matches.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>def get_protocol(self) -&gt; int | None:\n    \"\"\"Get the IP protocol number from IPv4/IPv6 matches.\"\"\"\n    if self.ipv4 and self.ipv4.protocol:\n        return self.ipv4.protocol\n    if self.ipv6 and self.ipv6.next_header:\n        return self.ipv6.next_header\n    return None\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.ACEMatches.has_matches","title":"<code>has_matches()</code>","text":"<p>Check if any match conditions are specified.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>def has_matches(self) -&gt; bool:\n    \"\"\"Check if any match conditions are specified.\"\"\"\n    return any(\n        [self.ipv4, self.ipv6, self.tcp, self.udp, self.icmp, self.eth, self.mud]\n    )\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.IPv4Match","title":"<code>mudparser.models.matches.IPv4Match</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>IPv4 header match conditions.</p> <p>Attributes:</p> Name Type Description <code>protocol</code> <code>int | None</code> <p>IP protocol number (e.g., 6 for TCP, 17 for UDP).</p> <code>src_network</code> <code>str | None</code> <p>Source network in CIDR notation.</p> <code>dst_network</code> <code>str | None</code> <p>Destination network in CIDR notation.</p> <code>src_dnsname</code> <code>str | None</code> <p>Source DNS name (ietf-acldns extension).</p> <code>dst_dnsname</code> <code>str | None</code> <p>Destination DNS name (ietf-acldns extension).</p> <code>dscp</code> <code>int | None</code> <p>Differentiated Services Code Point.</p> <code>ecn</code> <code>int | None</code> <p>Explicit Congestion Notification.</p> <code>length</code> <code>int | None</code> <p>Total packet length.</p> <code>ttl</code> <code>int | None</code> <p>Time to Live.</p> <code>ihl</code> <code>int | None</code> <p>Internet Header Length.</p> <code>flags</code> <code>str | None</code> <p>IP flags.</p> <code>offset</code> <code>int | None</code> <p>Fragment offset.</p> <code>identification</code> <code>int | None</code> <p>IP identification field.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>class IPv4Match(BaseModel):\n    \"\"\"\n    IPv4 header match conditions.\n\n    Attributes:\n        protocol: IP protocol number (e.g., 6 for TCP, 17 for UDP).\n        src_network: Source network in CIDR notation.\n        dst_network: Destination network in CIDR notation.\n        src_dnsname: Source DNS name (ietf-acldns extension).\n        dst_dnsname: Destination DNS name (ietf-acldns extension).\n        dscp: Differentiated Services Code Point.\n        ecn: Explicit Congestion Notification.\n        length: Total packet length.\n        ttl: Time to Live.\n        ihl: Internet Header Length.\n        flags: IP flags.\n        offset: Fragment offset.\n        identification: IP identification field.\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    protocol: int | None = None\n    src_network: str | None = Field(None, alias=\"source-ipv4-network\")\n    dst_network: str | None = Field(None, alias=\"destination-ipv4-network\")\n    src_dnsname: str | None = Field(None, alias=\"ietf-acldns:src-dnsname\")\n    dst_dnsname: str | None = Field(None, alias=\"ietf-acldns:dst-dnsname\")\n    dscp: int | None = None\n    ecn: int | None = None\n    length: int | None = None\n    ttl: int | None = None\n    ihl: int | None = None\n    flags: str | None = None\n    offset: int | None = None\n    identification: int | None = None\n\n    @field_validator(\"protocol\")\n    @classmethod\n    def validate_protocol(cls, v: int | None) -&gt; int | None:\n        if v is not None and not 0 &lt;= v &lt;= 255:\n            raise ValueError(\"Protocol must be between 0 and 255\")\n        return v\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.TCPMatch","title":"<code>mudparser.models.matches.TCPMatch</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>TCP header match conditions.</p> <p>Attributes:</p> Name Type Description <code>src_port</code> <code>PortMatch | None</code> <p>Source port matching specification.</p> <code>dst_port</code> <code>PortMatch | None</code> <p>Destination port matching specification.</p> <code>direction_initiated</code> <code>DirectionInitiated | None</code> <p>Connection initiation direction (MUD extension).</p> <code>sequence_number</code> <code>int | None</code> <p>TCP sequence number.</p> <code>acknowledgement_number</code> <code>int | None</code> <p>TCP acknowledgement number.</p> <code>data_offset</code> <code>int | None</code> <p>Data offset.</p> <code>reserved</code> <code>int | None</code> <p>Reserved bits.</p> <code>flags</code> <code>str | None</code> <p>TCP flags (URG, ACK, PSH, RST, SYN, FIN).</p> <code>window_size</code> <code>int | None</code> <p>TCP window size.</p> <code>urgent_pointer</code> <code>int | None</code> <p>Urgent pointer.</p> <code>options</code> <code>str | None</code> <p>TCP options.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>class TCPMatch(BaseModel):\n    \"\"\"\n    TCP header match conditions.\n\n    Attributes:\n        src_port: Source port matching specification.\n        dst_port: Destination port matching specification.\n        direction_initiated: Connection initiation direction (MUD extension).\n        sequence_number: TCP sequence number.\n        acknowledgement_number: TCP acknowledgement number.\n        data_offset: Data offset.\n        reserved: Reserved bits.\n        flags: TCP flags (URG, ACK, PSH, RST, SYN, FIN).\n        window_size: TCP window size.\n        urgent_pointer: Urgent pointer.\n        options: TCP options.\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    src_port: PortMatch | None = Field(None, alias=\"source-port\")\n    dst_port: PortMatch | None = Field(None, alias=\"destination-port\")\n    direction_initiated: DirectionInitiated | None = Field(\n        None, alias=\"ietf-mud:direction-initiated\"\n    )\n    sequence_number: int | None = Field(None, alias=\"sequence-number\")\n    acknowledgement_number: int | None = Field(None, alias=\"acknowledgement-number\")\n    data_offset: int | None = Field(None, alias=\"data-offset\")\n    reserved: int | None = None\n    flags: str | None = None\n    window_size: int | None = Field(None, alias=\"window-size\")\n    urgent_pointer: int | None = Field(None, alias=\"urgent-pointer\")\n    options: str | None = None\n\n    @classmethod\n    def from_json(cls, data: dict[str, Any]) -&gt; \"TCPMatch\":\n        \"\"\"Create TCPMatch from JSON data, handling port objects.\"\"\"\n        processed = {}\n        for key, value in data.items():\n            if key in (\"source-port\", \"destination-port\") and isinstance(value, dict):\n                processed[key] = PortMatch(**value)\n            else:\n                processed[key] = value\n        return cls(**processed)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.TCPMatch.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Create TCPMatch from JSON data, handling port objects.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>@classmethod\ndef from_json(cls, data: dict[str, Any]) -&gt; \"TCPMatch\":\n    \"\"\"Create TCPMatch from JSON data, handling port objects.\"\"\"\n    processed = {}\n    for key, value in data.items():\n        if key in (\"source-port\", \"destination-port\") and isinstance(value, dict):\n            processed[key] = PortMatch(**value)\n        else:\n            processed[key] = value\n    return cls(**processed)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.PortMatch","title":"<code>mudparser.models.matches.PortMatch</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Port matching specification.</p> <p>Supports single port matching with operators (eq, neq, lt, gt) and port range matching.</p> <p>Attributes:</p> Name Type Description <code>operator</code> <code>PortOperator</code> <p>The comparison operator.</p> <code>port</code> <code>Annotated[int, Field(ge=0, le=65535)]</code> <p>The port number (or lower bound for range).</p> <code>upper_port</code> <code>Annotated[int | None, Field(ge=0, le=65535, alias='upper-port')]</code> <p>Upper bound for range operator (required for range).</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>class PortMatch(BaseModel):\n    \"\"\"\n    Port matching specification.\n\n    Supports single port matching with operators (eq, neq, lt, gt)\n    and port range matching.\n\n    Attributes:\n        operator: The comparison operator.\n        port: The port number (or lower bound for range).\n        upper_port: Upper bound for range operator (required for range).\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    operator: PortOperator = Field(default=PortOperator.EQ)\n    port: Annotated[int, Field(ge=0, le=65535)]\n    upper_port: Annotated[int | None, Field(ge=0, le=65535, alias=\"upper-port\")] = None\n\n    @model_validator(mode=\"after\")\n    def validate_range(self) -&gt; \"PortMatch\":\n        \"\"\"Ensure upper_port is set for range operator and valid.\"\"\"\n        if self.operator == PortOperator.RANGE:\n            if self.upper_port is None:\n                raise ValueError(\"upper_port is required for range operator\")\n            if self.upper_port &lt;= self.port:\n                raise ValueError(\"upper_port must be greater than port\")\n        return self\n\n    def matches_port(self, port: int) -&gt; bool:\n        \"\"\"Check if a given port matches this specification.\"\"\"\n        match self.operator:\n            case PortOperator.EQ:\n                return port == self.port\n            case PortOperator.NEQ:\n                return port != self.port\n            case PortOperator.LT:\n                return port &lt; self.port\n            case PortOperator.GT:\n                return port &gt; self.port\n            case PortOperator.RANGE:\n                return self.port &lt;= port &lt;= (self.upper_port or self.port)\n\n    def __str__(self) -&gt; str:\n        if self.operator == PortOperator.RANGE:\n            return f\"{self.port}-{self.upper_port}\"\n        return f\"{self.operator.value} {self.port}\"\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.PortMatch.matches_port","title":"<code>matches_port(port)</code>","text":"<p>Check if a given port matches this specification.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>def matches_port(self, port: int) -&gt; bool:\n    \"\"\"Check if a given port matches this specification.\"\"\"\n    match self.operator:\n        case PortOperator.EQ:\n            return port == self.port\n        case PortOperator.NEQ:\n            return port != self.port\n        case PortOperator.LT:\n            return port &lt; self.port\n        case PortOperator.GT:\n            return port &gt; self.port\n        case PortOperator.RANGE:\n            return self.port &lt;= port &lt;= (self.upper_port or self.port)\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.PortMatch.validate_range","title":"<code>validate_range()</code>","text":"<p>Ensure upper_port is set for range operator and valid.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_range(self) -&gt; \"PortMatch\":\n    \"\"\"Ensure upper_port is set for range operator and valid.\"\"\"\n    if self.operator == PortOperator.RANGE:\n        if self.upper_port is None:\n            raise ValueError(\"upper_port is required for range operator\")\n        if self.upper_port &lt;= self.port:\n            raise ValueError(\"upper_port must be greater than port\")\n    return self\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.MUDMatch","title":"<code>mudparser.models.matches.MUDMatch</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>MUD-specific abstract match conditions (RFC 8520 Section 6).</p> <p>These matches allow specifying abstract network entities rather than specific IP addresses, enabling dynamic policy updates.</p> <p>Attributes:</p> Name Type Description <code>manufacturer</code> <code>str | None</code> <p>Match devices from specific manufacturer (by MUD URL authority).</p> <code>same_manufacturer</code> <code>list[Any] | None</code> <p>Match devices from same manufacturer as this device.</p> <code>model</code> <code>str | None</code> <p>Match devices with same MUD URL (same model).</p> <code>local_networks</code> <code>list[Any] | None</code> <p>Match traffic on local networks (not default route).</p> <code>controller</code> <code>str | None</code> <p>Match traffic to/from named controller class.</p> <code>my_controller</code> <code>list[Any] | None</code> <p>Match traffic to/from device-specific controller.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>class MUDMatch(BaseModel):\n    \"\"\"\n    MUD-specific abstract match conditions (RFC 8520 Section 6).\n\n    These matches allow specifying abstract network entities rather than\n    specific IP addresses, enabling dynamic policy updates.\n\n    Attributes:\n        manufacturer: Match devices from specific manufacturer (by MUD URL authority).\n        same_manufacturer: Match devices from same manufacturer as this device.\n        model: Match devices with same MUD URL (same model).\n        local_networks: Match traffic on local networks (not default route).\n        controller: Match traffic to/from named controller class.\n        my_controller: Match traffic to/from device-specific controller.\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    manufacturer: str | None = None\n    same_manufacturer: list[Any] | None = Field(None, alias=\"same-manufacturer\")\n    model: str | None = None\n    local_networks: list[Any] | None = Field(None, alias=\"local-networks\")\n    controller: str | None = None\n    my_controller: list[Any] | None = Field(None, alias=\"my-controller\")\n\n    def get_match_type(self) -&gt; str | None:\n        \"\"\"Return the type of MUD match that is set.\"\"\"\n        if self.manufacturer is not None:\n            return \"manufacturer\"\n        if self.same_manufacturer is not None:\n            return \"same-manufacturer\"\n        if self.model is not None:\n            return \"model\"\n        if self.local_networks is not None:\n            return \"local-networks\"\n        if self.controller is not None:\n            return \"controller\"\n        if self.my_controller is not None:\n            return \"my-controller\"\n        return None\n\n    def get_match_value(self) -&gt; Any:\n        \"\"\"Return the value of the set match type.\"\"\"\n        match_type = self.get_match_type()\n        if match_type:\n            return getattr(self, match_type.replace(\"-\", \"_\"))\n        return None\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.MUDMatch.get_match_type","title":"<code>get_match_type()</code>","text":"<p>Return the type of MUD match that is set.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>def get_match_type(self) -&gt; str | None:\n    \"\"\"Return the type of MUD match that is set.\"\"\"\n    if self.manufacturer is not None:\n        return \"manufacturer\"\n    if self.same_manufacturer is not None:\n        return \"same-manufacturer\"\n    if self.model is not None:\n        return \"model\"\n    if self.local_networks is not None:\n        return \"local-networks\"\n    if self.controller is not None:\n        return \"controller\"\n    if self.my_controller is not None:\n        return \"my-controller\"\n    return None\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.matches.MUDMatch.get_match_value","title":"<code>get_match_value()</code>","text":"<p>Return the value of the set match type.</p> Source code in <code>src/mudparser/models/matches.py</code> <pre><code>def get_match_value(self) -&gt; Any:\n    \"\"\"Return the value of the set match type.\"\"\"\n    match_type = self.get_match_type()\n    if match_type:\n        return getattr(self, match_type.replace(\"-\", \"_\"))\n    return None\n</code></pre>"},{"location":"api-reference/models/#tls-profile-rfc-9761","title":"TLS Profile (RFC 9761)","text":""},{"location":"api-reference/models/#mudparser.models.tls.TLSProfile","title":"<code>mudparser.models.tls.TLSProfile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete TLS/DTLS profile for a device (RFC 9761).</p> <p>This profile describes the expected TLS behavior for an IoT device, allowing network security services to detect unexpected TLS usage that might indicate compromise or malfunction.</p> <p>Attributes:</p> Name Type Description <code>client_profile</code> <code>TLSClientProfile | None</code> <p>TLS profile for outgoing connections.</p> <code>server_profile</code> <code>TLSServerProfile | None</code> <p>TLS profile for incoming connections.</p> <code>description</code> <code>str | None</code> <p>Human-readable description.</p> Source code in <code>src/mudparser/models/tls.py</code> <pre><code>class TLSProfile(BaseModel):\n    \"\"\"\n    Complete TLS/DTLS profile for a device (RFC 9761).\n\n    This profile describes the expected TLS behavior for an IoT device,\n    allowing network security services to detect unexpected TLS usage\n    that might indicate compromise or malfunction.\n\n    Attributes:\n        client_profile: TLS profile for outgoing connections.\n        server_profile: TLS profile for incoming connections.\n        description: Human-readable description.\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    client_profile: TLSClientProfile | None = Field(\n        None, alias=\"client-profile\"\n    )\n    server_profile: TLSServerProfile | None = Field(\n        None, alias=\"server-profile\"\n    )\n    description: str | None = None\n\n    def has_client_profile(self) -&gt; bool:\n        \"\"\"Check if a client profile is defined.\"\"\"\n        return self.client_profile is not None\n\n    def has_server_profile(self) -&gt; bool:\n        \"\"\"Check if a server profile is defined.\"\"\"\n        return self.server_profile is not None\n\n    def get_all_cipher_suites(self) -&gt; list[CipherSuite]:\n        \"\"\"Get all cipher suites from both profiles.\"\"\"\n        suites: list[CipherSuite] = []\n        if self.client_profile:\n            suites.extend(self.client_profile.cipher_suites)\n        if self.server_profile:\n            suites.extend(self.server_profile.cipher_suites)\n        return suites\n\n    def get_all_tls_versions(self) -&gt; set[TLSVersion]:\n        \"\"\"Get all TLS versions from both profiles.\"\"\"\n        versions: set[TLSVersion] = set()\n        if self.client_profile:\n            versions.update(self.client_profile.tls_versions)\n        if self.server_profile:\n            versions.update(self.server_profile.tls_versions)\n        return versions\n\n    def has_security_concerns(self) -&gt; list[str]:\n        \"\"\"\n        Check for potential security concerns in the profile.\n\n        Returns:\n            List of security concern descriptions.\n        \"\"\"\n        concerns: list[str] = []\n\n        # Check for deprecated versions\n        all_versions = self.get_all_tls_versions()\n        deprecated = [v for v in all_versions if v.is_deprecated]\n        if deprecated:\n            concerns.append(\n                f\"Deprecated TLS versions allowed: {', '.join(v.value for v in deprecated)}\"\n            )\n\n        # Check for insecure cipher suites\n        for suite in self.get_all_cipher_suites():\n            if not suite.is_secure():\n                concerns.append(f\"Potentially insecure cipher suite: {suite.name}\")\n\n        # Check client profile specifics\n        if self.client_profile:\n            if not self.client_profile.sni_required:\n                concerns.append(\"SNI not required for client connections\")\n            if not self.client_profile.spki_pins:\n                concerns.append(\"No certificate pinning configured\")\n\n        return concerns\n\n    @classmethod\n    def from_json(cls, data: dict[str, Any]) -&gt; \"TLSProfile\":\n        \"\"\"Create TLSProfile from JSON data.\"\"\"\n        client_data = data.get(\"client-profile\")\n        server_data = data.get(\"server-profile\")\n\n        client_profile = None\n        if client_data:\n            # Parse cipher suites\n            cipher_suites = [\n                CipherSuite.from_name(cs) if isinstance(cs, str) else CipherSuite(**cs)\n                for cs in client_data.get(\"cipher-suites\", [])\n            ]\n            # Parse SPKI pins\n            spki_pins = [\n                SPKIHash(**pin) if isinstance(pin, dict) else SPKIHash(value=pin)\n                for pin in client_data.get(\"spki-pins\", [])\n            ]\n            client_profile = TLSClientProfile(\n                tls_versions=[TLSVersion(v) for v in client_data.get(\"tls-versions\", [])],\n                cipher_suites=cipher_suites,\n                spki_pins=spki_pins,\n                client_auth=ClientAuthentication(\n                    client_data.get(\"client-authentication\", \"none\")\n                ),\n                alpn_protocols=client_data.get(\"alpn-protocols\", []),\n                sni_required=client_data.get(\"sni-required\", True),\n            )\n\n        server_profile = None\n        if server_data:\n            cipher_suites = [\n                CipherSuite.from_name(cs) if isinstance(cs, str) else CipherSuite(**cs)\n                for cs in server_data.get(\"cipher-suites\", [])\n            ]\n            server_profile = TLSServerProfile(\n                tls_versions=[TLSVersion(v) for v in server_data.get(\"tls-versions\", [])],\n                cipher_suites=cipher_suites,\n                client_auth=ClientAuthentication(\n                    server_data.get(\"client-authentication\", \"none\")\n                ),\n                alpn_protocols=server_data.get(\"alpn-protocols\", []),\n            )\n\n        return cls(\n            client_profile=client_profile,\n            server_profile=server_profile,\n            description=data.get(\"description\"),\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert to dictionary representation.\"\"\"\n        result: dict[str, Any] = {}\n\n        if self.client_profile:\n            result[\"client-profile\"] = self.client_profile.model_dump(\n                by_alias=True, exclude_none=True\n            )\n\n        if self.server_profile:\n            result[\"server-profile\"] = self.server_profile.model_dump(\n                by_alias=True, exclude_none=True\n            )\n\n        if self.description:\n            result[\"description\"] = self.description\n\n        return result\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.tls.TLSProfile.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Create TLSProfile from JSON data.</p> Source code in <code>src/mudparser/models/tls.py</code> <pre><code>@classmethod\ndef from_json(cls, data: dict[str, Any]) -&gt; \"TLSProfile\":\n    \"\"\"Create TLSProfile from JSON data.\"\"\"\n    client_data = data.get(\"client-profile\")\n    server_data = data.get(\"server-profile\")\n\n    client_profile = None\n    if client_data:\n        # Parse cipher suites\n        cipher_suites = [\n            CipherSuite.from_name(cs) if isinstance(cs, str) else CipherSuite(**cs)\n            for cs in client_data.get(\"cipher-suites\", [])\n        ]\n        # Parse SPKI pins\n        spki_pins = [\n            SPKIHash(**pin) if isinstance(pin, dict) else SPKIHash(value=pin)\n            for pin in client_data.get(\"spki-pins\", [])\n        ]\n        client_profile = TLSClientProfile(\n            tls_versions=[TLSVersion(v) for v in client_data.get(\"tls-versions\", [])],\n            cipher_suites=cipher_suites,\n            spki_pins=spki_pins,\n            client_auth=ClientAuthentication(\n                client_data.get(\"client-authentication\", \"none\")\n            ),\n            alpn_protocols=client_data.get(\"alpn-protocols\", []),\n            sni_required=client_data.get(\"sni-required\", True),\n        )\n\n    server_profile = None\n    if server_data:\n        cipher_suites = [\n            CipherSuite.from_name(cs) if isinstance(cs, str) else CipherSuite(**cs)\n            for cs in server_data.get(\"cipher-suites\", [])\n        ]\n        server_profile = TLSServerProfile(\n            tls_versions=[TLSVersion(v) for v in server_data.get(\"tls-versions\", [])],\n            cipher_suites=cipher_suites,\n            client_auth=ClientAuthentication(\n                server_data.get(\"client-authentication\", \"none\")\n            ),\n            alpn_protocols=server_data.get(\"alpn-protocols\", []),\n        )\n\n    return cls(\n        client_profile=client_profile,\n        server_profile=server_profile,\n        description=data.get(\"description\"),\n    )\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.tls.TLSProfile.get_all_cipher_suites","title":"<code>get_all_cipher_suites()</code>","text":"<p>Get all cipher suites from both profiles.</p> Source code in <code>src/mudparser/models/tls.py</code> <pre><code>def get_all_cipher_suites(self) -&gt; list[CipherSuite]:\n    \"\"\"Get all cipher suites from both profiles.\"\"\"\n    suites: list[CipherSuite] = []\n    if self.client_profile:\n        suites.extend(self.client_profile.cipher_suites)\n    if self.server_profile:\n        suites.extend(self.server_profile.cipher_suites)\n    return suites\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.tls.TLSProfile.get_all_tls_versions","title":"<code>get_all_tls_versions()</code>","text":"<p>Get all TLS versions from both profiles.</p> Source code in <code>src/mudparser/models/tls.py</code> <pre><code>def get_all_tls_versions(self) -&gt; set[TLSVersion]:\n    \"\"\"Get all TLS versions from both profiles.\"\"\"\n    versions: set[TLSVersion] = set()\n    if self.client_profile:\n        versions.update(self.client_profile.tls_versions)\n    if self.server_profile:\n        versions.update(self.server_profile.tls_versions)\n    return versions\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.tls.TLSProfile.has_client_profile","title":"<code>has_client_profile()</code>","text":"<p>Check if a client profile is defined.</p> Source code in <code>src/mudparser/models/tls.py</code> <pre><code>def has_client_profile(self) -&gt; bool:\n    \"\"\"Check if a client profile is defined.\"\"\"\n    return self.client_profile is not None\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.tls.TLSProfile.has_security_concerns","title":"<code>has_security_concerns()</code>","text":"<p>Check for potential security concerns in the profile.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of security concern descriptions.</p> Source code in <code>src/mudparser/models/tls.py</code> <pre><code>def has_security_concerns(self) -&gt; list[str]:\n    \"\"\"\n    Check for potential security concerns in the profile.\n\n    Returns:\n        List of security concern descriptions.\n    \"\"\"\n    concerns: list[str] = []\n\n    # Check for deprecated versions\n    all_versions = self.get_all_tls_versions()\n    deprecated = [v for v in all_versions if v.is_deprecated]\n    if deprecated:\n        concerns.append(\n            f\"Deprecated TLS versions allowed: {', '.join(v.value for v in deprecated)}\"\n        )\n\n    # Check for insecure cipher suites\n    for suite in self.get_all_cipher_suites():\n        if not suite.is_secure():\n            concerns.append(f\"Potentially insecure cipher suite: {suite.name}\")\n\n    # Check client profile specifics\n    if self.client_profile:\n        if not self.client_profile.sni_required:\n            concerns.append(\"SNI not required for client connections\")\n        if not self.client_profile.spki_pins:\n            concerns.append(\"No certificate pinning configured\")\n\n    return concerns\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.tls.TLSProfile.has_server_profile","title":"<code>has_server_profile()</code>","text":"<p>Check if a server profile is defined.</p> Source code in <code>src/mudparser/models/tls.py</code> <pre><code>def has_server_profile(self) -&gt; bool:\n    \"\"\"Check if a server profile is defined.\"\"\"\n    return self.server_profile is not None\n</code></pre>"},{"location":"api-reference/models/#mudparser.models.tls.TLSProfile.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary representation.</p> Source code in <code>src/mudparser/models/tls.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to dictionary representation.\"\"\"\n    result: dict[str, Any] = {}\n\n    if self.client_profile:\n        result[\"client-profile\"] = self.client_profile.model_dump(\n            by_alias=True, exclude_none=True\n        )\n\n    if self.server_profile:\n        result[\"server-profile\"] = self.server_profile.model_dump(\n            by_alias=True, exclude_none=True\n        )\n\n    if self.description:\n        result[\"description\"] = self.description\n\n    return result\n</code></pre>"},{"location":"api-reference/parser/","title":"Parser API Reference","text":""},{"location":"api-reference/parser/#mudparser.parser.MUDParser","title":"<code>mudparser.parser.MUDParser</code>","text":"<p>Main parser class for MUD profiles.</p> <p>This class provides a unified interface for parsing MUD profiles from various sources (files, strings, URLs) and accessing their contents.</p> <p>Attributes:</p> Name Type Description <code>profile</code> <code>MUDProfile</code> <p>The parsed MUD profile.</p> <code>source</code> <code>str</code> <p>Description of the data source.</p> Example <p>parser = MUDParser.from_file(\"device.mud.json\") print(parser.profile.mud.systeminfo) parser.validate() rules = parser.export.to_iptables(device_ip=\"192.168.1.100\")</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>class MUDParser:\n    \"\"\"\n    Main parser class for MUD profiles.\n\n    This class provides a unified interface for parsing MUD profiles from\n    various sources (files, strings, URLs) and accessing their contents.\n\n    Attributes:\n        profile: The parsed MUD profile.\n        source: Description of the data source.\n\n    Example:\n        &gt;&gt;&gt; parser = MUDParser.from_file(\"device.mud.json\")\n        &gt;&gt;&gt; print(parser.profile.mud.systeminfo)\n        &gt;&gt;&gt; parser.validate()\n        &gt;&gt;&gt; rules = parser.export.to_iptables(device_ip=\"192.168.1.100\")\n    \"\"\"\n\n    def __init__(self, profile: MUDProfile, source: str = \"unknown\") -&gt; None:\n        \"\"\"\n        Initialize the parser with a parsed profile.\n\n        Args:\n            profile: The parsed MUD profile.\n            source: Description of where the profile came from.\n        \"\"\"\n        self._profile = profile\n        self._source = source\n        self._validated = False\n        self._exporter: MUDExporter | None = None\n\n    @property\n    def profile(self) -&gt; MUDProfile:\n        \"\"\"Get the parsed MUD profile.\"\"\"\n        return self._profile\n\n    @property\n    def mud(self) -&gt; Any:\n        \"\"\"Get the MUD container (shortcut).\"\"\"\n        return self._profile.mud\n\n    @property\n    def source(self) -&gt; str:\n        \"\"\"Get the source description.\"\"\"\n        return self._source\n\n    @property\n    def export(self) -&gt; \"MUDExporter\":\n        \"\"\"Get the exporter for this profile.\"\"\"\n        if self._exporter is None:\n            from mudparser.exporters import MUDExporter\n            self._exporter = MUDExporter(self._profile)\n        return self._exporter\n\n    # =========================================================================\n    # Factory Methods\n    # =========================================================================\n\n    @classmethod\n    def from_file(cls, file_path: str | Path) -&gt; \"MUDParser\":\n        \"\"\"\n        Parse a MUD profile from a file.\n\n        Args:\n            file_path: Path to the MUD JSON file.\n\n        Returns:\n            MUDParser instance with the parsed profile.\n\n        Raises:\n            MUDFileNotFoundError: If the file doesn't exist.\n            MUDSchemaError: If the JSON is malformed.\n            MUDValidationError: If the profile doesn't conform to the schema.\n        \"\"\"\n        path = Path(file_path)\n\n        if not path.exists():\n            raise MUDFileNotFoundError(str(path))\n\n        try:\n            with path.open(\"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n        except json.JSONDecodeError as e:\n            raise MUDSchemaError(\n                f\"Invalid JSON in file: {e}\",\n                path=str(path),\n            ) from e\n\n        profile = cls._parse_json_data(data)\n        return cls(profile, source=str(path))\n\n    @classmethod\n    def from_string(cls, json_string: str, source: str = \"string\") -&gt; \"MUDParser\":\n        \"\"\"\n        Parse a MUD profile from a JSON string.\n\n        Args:\n            json_string: JSON string containing the MUD profile.\n            source: Description of the source for error messages.\n\n        Returns:\n            MUDParser instance with the parsed profile.\n\n        Raises:\n            MUDSchemaError: If the JSON is malformed.\n            MUDValidationError: If the profile doesn't conform to the schema.\n        \"\"\"\n        try:\n            data = json.loads(json_string)\n        except json.JSONDecodeError as e:\n            raise MUDSchemaError(f\"Invalid JSON string: {e}\") from e\n\n        profile = cls._parse_json_data(data)\n        return cls(profile, source=source)\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any], source: str = \"dict\") -&gt; \"MUDParser\":\n        \"\"\"\n        Parse a MUD profile from a dictionary.\n\n        Args:\n            data: Dictionary containing the MUD profile data.\n            source: Description of the source for error messages.\n\n        Returns:\n            MUDParser instance with the parsed profile.\n\n        Raises:\n            MUDValidationError: If the profile doesn't conform to the schema.\n        \"\"\"\n        profile = cls._parse_json_data(data)\n        return cls(profile, source=source)\n\n    @classmethod\n    def from_file_object(cls, file_obj: TextIO, source: str = \"file\") -&gt; \"MUDParser\":\n        \"\"\"\n        Parse a MUD profile from a file object.\n\n        Args:\n            file_obj: File-like object to read from.\n            source: Description of the source for error messages.\n\n        Returns:\n            MUDParser instance with the parsed profile.\n\n        Raises:\n            MUDSchemaError: If the JSON is malformed.\n            MUDValidationError: If the profile doesn't conform to the schema.\n        \"\"\"\n        try:\n            data = json.load(file_obj)\n        except json.JSONDecodeError as e:\n            raise MUDSchemaError(f\"Invalid JSON: {e}\") from e\n\n        profile = cls._parse_json_data(data)\n        return cls(profile, source=source)\n\n    @classmethod\n    def from_url(\n        cls,\n        url: str,\n        timeout: float = 30.0,\n        verify_ssl: bool = True,\n    ) -&gt; \"MUDParser\":\n        \"\"\"\n        Fetch and parse a MUD profile from a URL.\n\n        Args:\n            url: URL to fetch the MUD profile from.\n            timeout: Request timeout in seconds.\n            verify_ssl: Whether to verify SSL certificates.\n\n        Returns:\n            MUDParser instance with the parsed profile.\n\n        Raises:\n            MUDNetworkError: If the request fails.\n            MUDSchemaError: If the response isn't valid JSON.\n            MUDValidationError: If the profile doesn't conform to the schema.\n        \"\"\"\n        try:\n            response = httpx.get(\n                url,\n                timeout=timeout,\n                verify=verify_ssl,\n                follow_redirects=True,\n                headers={\"Accept\": \"application/mud+json, application/json\"},\n            )\n            response.raise_for_status()\n        except httpx.TimeoutException as e:\n            raise MUDNetworkError(f\"Request timed out: {e}\", url=url) from e\n        except httpx.HTTPStatusError as e:\n            raise MUDNetworkError(\n                f\"HTTP error {e.response.status_code}: {e.response.reason_phrase}\",\n                url=url,\n                status_code=e.response.status_code,\n            ) from e\n        except httpx.RequestError as e:\n            raise MUDNetworkError(f\"Network error: {e}\", url=url) from e\n\n        try:\n            data = response.json()\n        except json.JSONDecodeError as e:\n            raise MUDSchemaError(f\"Invalid JSON in response: {e}\") from e\n\n        profile = cls._parse_json_data(data)\n        return cls(profile, source=url)\n\n    @classmethod\n    async def from_url_async(\n        cls,\n        url: str,\n        timeout: float = 30.0,\n        verify_ssl: bool = True,\n    ) -&gt; \"MUDParser\":\n        \"\"\"\n        Asynchronously fetch and parse a MUD profile from a URL.\n\n        Args:\n            url: URL to fetch the MUD profile from.\n            timeout: Request timeout in seconds.\n            verify_ssl: Whether to verify SSL certificates.\n\n        Returns:\n            MUDParser instance with the parsed profile.\n\n        Raises:\n            MUDNetworkError: If the request fails.\n            MUDSchemaError: If the response isn't valid JSON.\n            MUDValidationError: If the profile doesn't conform to the schema.\n        \"\"\"\n        async with httpx.AsyncClient(verify=verify_ssl) as client:\n            try:\n                response = await client.get(\n                    url,\n                    timeout=timeout,\n                    follow_redirects=True,\n                    headers={\"Accept\": \"application/mud+json, application/json\"},\n                )\n                response.raise_for_status()\n            except httpx.TimeoutException as e:\n                raise MUDNetworkError(f\"Request timed out: {e}\", url=url) from e\n            except httpx.HTTPStatusError as e:\n                raise MUDNetworkError(\n                    f\"HTTP error {e.response.status_code}: {e.response.reason_phrase}\",\n                    url=url,\n                    status_code=e.response.status_code,\n                ) from e\n            except httpx.RequestError as e:\n                raise MUDNetworkError(f\"Network error: {e}\", url=url) from e\n\n        try:\n            data = response.json()\n        except json.JSONDecodeError as e:\n            raise MUDSchemaError(f\"Invalid JSON in response: {e}\") from e\n\n        profile = cls._parse_json_data(data)\n        return cls(profile, source=url)\n\n    # =========================================================================\n    # Parsing Implementation\n    # =========================================================================\n\n    @classmethod\n    def _parse_json_data(cls, data: dict[str, Any]) -&gt; MUDProfile:\n        \"\"\"\n        Parse JSON data into a MUDProfile.\n\n        Args:\n            data: Dictionary containing the MUD profile data.\n\n        Returns:\n            Parsed MUDProfile instance.\n\n        Raises:\n            MUDSchemaError: If required fields are missing.\n            MUDValidationError: If validation fails.\n        \"\"\"\n        # Check for required top-level keys\n        if \"ietf-mud:mud\" not in data:\n            raise MUDSchemaError(\n                \"Missing required 'ietf-mud:mud' container\",\n                path=\"$\",\n            )\n\n        if \"ietf-access-control-list:access-lists\" not in data:\n            raise MUDSchemaError(\n                \"Missing required 'ietf-access-control-list:access-lists' container\",\n                path=\"$\",\n            )\n\n        try:\n            return MUDProfile.from_json(data)\n        except ValueError as e:\n            raise MUDValidationError(str(e)) from e\n        except KeyError as e:\n            raise MUDSchemaError(f\"Missing required field: {e}\") from e\n\n    # =========================================================================\n    # Validation\n    # =========================================================================\n\n    def validate(self, strict: bool = False) -&gt; list[str]:\n        \"\"\"\n        Validate the MUD profile.\n\n        Performs semantic validation beyond the basic schema checks,\n        including cross-reference validation and RFC compliance checks.\n\n        Args:\n            strict: If True, raise exception on first error.\n                   If False, collect and return all errors.\n\n        Returns:\n            List of validation error messages (empty if valid).\n\n        Raises:\n            MUDValidationError: If strict=True and validation fails.\n        \"\"\"\n        errors: list[str] = []\n\n        # Validate ACL references\n        errors.extend(self._validate_acl_references())\n\n        # Validate MUD URL format\n        errors.extend(self._validate_mud_url())\n\n        # Validate cache validity\n        errors.extend(self._validate_cache_validity())\n\n        # Validate direction-initiated usage\n        errors.extend(self._validate_direction_initiated())\n\n        if strict and errors:\n            raise MUDValidationError(\n                f\"Profile validation failed with {len(errors)} error(s)\",\n                errors=[{\"message\": e} for e in errors],\n            )\n\n        self._validated = len(errors) == 0\n        return errors\n\n    def _validate_acl_references(self) -&gt; list[str]:\n        \"\"\"Validate that all ACL references can be resolved.\"\"\"\n        errors: list[str] = []\n        acl_names = {acl.name for acl in self._profile.acls.acl}\n\n        for policy_name, policy in [\n            (\"from-device-policy\", self._profile.mud.from_device_policy),\n            (\"to-device-policy\", self._profile.mud.to_device_policy),\n        ]:\n            for acl_ref in policy.access_lists.access_list:\n                if acl_ref.name not in acl_names:\n                    errors.append(\n                        f\"ACL '{acl_ref.name}' referenced in {policy_name} does not exist\"\n                    )\n\n        return errors\n\n    def _validate_mud_url(self) -&gt; list[str]:\n        \"\"\"Validate the MUD URL format.\"\"\"\n        errors: list[str] = []\n        url = str(self._profile.mud.mud_url)\n\n        if not url.startswith(\"https://\"):\n            errors.append(\n                f\"MUD URL should use HTTPS scheme: {url}\"\n            )\n\n        return errors\n\n    def _validate_cache_validity(self) -&gt; list[str]:\n        \"\"\"Validate cache validity is within RFC bounds.\"\"\"\n        errors: list[str] = []\n        validity = self._profile.mud.cache_validity\n\n        if not 1 &lt;= validity &lt;= 168:\n            errors.append(\n                f\"Cache validity {validity} is outside valid range (1-168 hours)\"\n            )\n\n        return errors\n\n    def _validate_direction_initiated(self) -&gt; list[str]:\n        \"\"\"Validate that direction-initiated is only used with TCP.\"\"\"\n        errors: list[str] = []\n\n        for acl in self._profile.acls.acl:\n            for entry in acl.entries:\n                if entry.matches.tcp and entry.matches.tcp.direction_initiated:\n                    # This is valid - TCP with direction-initiated\n                    continue\n\n                # Check if direction-initiated is used without TCP\n                if (entry.matches.udp and\n                    hasattr(entry.matches.udp, 'direction_initiated') and\n                    entry.matches.udp.direction_initiated):\n                    errors.append(\n                        f\"ACE '{entry.name}' uses direction-initiated with UDP \"\n                        f\"(only valid for TCP)\"\n                    )\n\n        return errors\n\n    @property\n    def is_validated(self) -&gt; bool:\n        \"\"\"Check if the profile has been validated.\"\"\"\n        return self._validated\n\n    # =========================================================================\n    # Profile Access Methods\n    # =========================================================================\n\n    def get_acl(self, name: str) -&gt; AccessControlList | None:\n        \"\"\"\n        Get an ACL by name.\n\n        Args:\n            name: The ACL name to look up.\n\n        Returns:\n            The ACL if found, None otherwise.\n        \"\"\"\n        return self._profile.get_acl(name)\n\n    def get_from_device_acls(self) -&gt; list[AccessControlList]:\n        \"\"\"Get all ACLs for outbound (from-device) traffic.\"\"\"\n        return self._profile.get_from_device_acls()\n\n    def get_to_device_acls(self) -&gt; list[AccessControlList]:\n        \"\"\"Get all ACLs for inbound (to-device) traffic.\"\"\"\n        return self._profile.get_to_device_acls()\n\n    def get_all_entries(self) -&gt; list[tuple[str, AccessControlEntry]]:\n        \"\"\"\n        Get all ACEs from all ACLs with their direction.\n\n        Returns:\n            List of (direction, ACE) tuples.\n        \"\"\"\n        entries: list[tuple[str, AccessControlEntry]] = []\n\n        for acl in self.get_from_device_acls():\n            for entry in acl.entries:\n                entries.append((\"from\", entry))\n\n        for acl in self.get_to_device_acls():\n            for entry in acl.entries:\n                entries.append((\"to\", entry))\n\n        return entries\n\n    def get_dns_names(self) -&gt; set[str]:\n        \"\"\"Get all DNS names referenced in the profile.\"\"\"\n        return self._profile.get_all_dns_names()\n\n    def get_ports(self) -&gt; dict[str, set[int]]:\n        \"\"\"Get all ports referenced in the profile.\"\"\"\n        return self._profile.get_all_ports()\n\n    # =========================================================================\n    # Output Methods\n    # =========================================================================\n\n    def print_rules(self) -&gt; None:\n        \"\"\"Print all rules in human-readable format.\"\"\"\n        print(self._profile.print_rules())\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert the profile to a dictionary.\"\"\"\n        return self._profile.to_dict()\n\n    def to_json(self, indent: int = 2) -&gt; str:\n        \"\"\"\n        Convert the profile to a JSON string.\n\n        Args:\n            indent: JSON indentation level.\n\n        Returns:\n            JSON string representation.\n        \"\"\"\n        return json.dumps(self.to_dict(), indent=indent, default=str)\n\n    # =========================================================================\n    # Summary and Information\n    # =========================================================================\n\n    def get_summary(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get a summary of the MUD profile.\n\n        Returns:\n            Dictionary with profile summary information.\n        \"\"\"\n        return {\n            \"url\": str(self._profile.mud.mud_url),\n            \"version\": self._profile.mud.mud_version,\n            \"systeminfo\": self._profile.mud.systeminfo,\n            \"last_update\": self._profile.mud.last_update.isoformat(),\n            \"cache_validity_hours\": self._profile.mud.cache_validity,\n            \"is_supported\": self._profile.mud.is_supported,\n            \"manufacturer\": self._profile.mud.mfg_name,\n            \"model\": self._profile.mud.model_name,\n            \"total_acls\": len(self._profile.acls.acl),\n            \"from_device_acls\": len(self.get_from_device_acls()),\n            \"to_device_acls\": len(self.get_to_device_acls()),\n            \"from_device_rules\": sum(len(acl.entries) for acl in self.get_from_device_acls()),\n            \"to_device_rules\": sum(len(acl.entries) for acl in self.get_to_device_acls()),\n            \"total_rules\": sum(len(acl.entries) for acl in self._profile.acls.acl),\n            \"dns_names\": list(self.get_dns_names()),\n            \"ports\": {k: list(v) for k, v in self.get_ports().items()},\n            \"source\": self._source,\n        }\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"MUDParser(url={self._profile.mud.mud_url!r}, \"\n            f\"systeminfo={self._profile.mud.systeminfo!r}, \"\n            f\"source={self._source!r})\"\n        )\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.profile","title":"<code>profile</code>  <code>property</code>","text":"<p>Get the parsed MUD profile.</p>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.mud","title":"<code>mud</code>  <code>property</code>","text":"<p>Get the MUD container (shortcut).</p>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.source","title":"<code>source</code>  <code>property</code>","text":"<p>Get the source description.</p>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.export","title":"<code>export</code>  <code>property</code>","text":"<p>Get the exporter for this profile.</p>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.is_validated","title":"<code>is_validated</code>  <code>property</code>","text":"<p>Check if the profile has been validated.</p>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.__init__","title":"<code>__init__(profile, source='unknown')</code>","text":"<p>Initialize the parser with a parsed profile.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>MUDProfile</code> <p>The parsed MUD profile.</p> required <code>source</code> <code>str</code> <p>Description of where the profile came from.</p> <code>'unknown'</code> Source code in <code>src/mudparser/parser.py</code> <pre><code>def __init__(self, profile: MUDProfile, source: str = \"unknown\") -&gt; None:\n    \"\"\"\n    Initialize the parser with a parsed profile.\n\n    Args:\n        profile: The parsed MUD profile.\n        source: Description of where the profile came from.\n    \"\"\"\n    self._profile = profile\n    self._source = source\n    self._validated = False\n    self._exporter: MUDExporter | None = None\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.from_file","title":"<code>from_file(file_path)</code>  <code>classmethod</code>","text":"<p>Parse a MUD profile from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to the MUD JSON file.</p> required <p>Returns:</p> Type Description <code>'MUDParser'</code> <p>MUDParser instance with the parsed profile.</p> <p>Raises:</p> Type Description <code>MUDFileNotFoundError</code> <p>If the file doesn't exist.</p> <code>MUDSchemaError</code> <p>If the JSON is malformed.</p> <code>MUDValidationError</code> <p>If the profile doesn't conform to the schema.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>@classmethod\ndef from_file(cls, file_path: str | Path) -&gt; \"MUDParser\":\n    \"\"\"\n    Parse a MUD profile from a file.\n\n    Args:\n        file_path: Path to the MUD JSON file.\n\n    Returns:\n        MUDParser instance with the parsed profile.\n\n    Raises:\n        MUDFileNotFoundError: If the file doesn't exist.\n        MUDSchemaError: If the JSON is malformed.\n        MUDValidationError: If the profile doesn't conform to the schema.\n    \"\"\"\n    path = Path(file_path)\n\n    if not path.exists():\n        raise MUDFileNotFoundError(str(path))\n\n    try:\n        with path.open(\"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n    except json.JSONDecodeError as e:\n        raise MUDSchemaError(\n            f\"Invalid JSON in file: {e}\",\n            path=str(path),\n        ) from e\n\n    profile = cls._parse_json_data(data)\n    return cls(profile, source=str(path))\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.from_string","title":"<code>from_string(json_string, source='string')</code>  <code>classmethod</code>","text":"<p>Parse a MUD profile from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json_string</code> <code>str</code> <p>JSON string containing the MUD profile.</p> required <code>source</code> <code>str</code> <p>Description of the source for error messages.</p> <code>'string'</code> <p>Returns:</p> Type Description <code>'MUDParser'</code> <p>MUDParser instance with the parsed profile.</p> <p>Raises:</p> Type Description <code>MUDSchemaError</code> <p>If the JSON is malformed.</p> <code>MUDValidationError</code> <p>If the profile doesn't conform to the schema.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>@classmethod\ndef from_string(cls, json_string: str, source: str = \"string\") -&gt; \"MUDParser\":\n    \"\"\"\n    Parse a MUD profile from a JSON string.\n\n    Args:\n        json_string: JSON string containing the MUD profile.\n        source: Description of the source for error messages.\n\n    Returns:\n        MUDParser instance with the parsed profile.\n\n    Raises:\n        MUDSchemaError: If the JSON is malformed.\n        MUDValidationError: If the profile doesn't conform to the schema.\n    \"\"\"\n    try:\n        data = json.loads(json_string)\n    except json.JSONDecodeError as e:\n        raise MUDSchemaError(f\"Invalid JSON string: {e}\") from e\n\n    profile = cls._parse_json_data(data)\n    return cls(profile, source=source)\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.from_dict","title":"<code>from_dict(data, source='dict')</code>  <code>classmethod</code>","text":"<p>Parse a MUD profile from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing the MUD profile data.</p> required <code>source</code> <code>str</code> <p>Description of the source for error messages.</p> <code>'dict'</code> <p>Returns:</p> Type Description <code>'MUDParser'</code> <p>MUDParser instance with the parsed profile.</p> <p>Raises:</p> Type Description <code>MUDValidationError</code> <p>If the profile doesn't conform to the schema.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any], source: str = \"dict\") -&gt; \"MUDParser\":\n    \"\"\"\n    Parse a MUD profile from a dictionary.\n\n    Args:\n        data: Dictionary containing the MUD profile data.\n        source: Description of the source for error messages.\n\n    Returns:\n        MUDParser instance with the parsed profile.\n\n    Raises:\n        MUDValidationError: If the profile doesn't conform to the schema.\n    \"\"\"\n    profile = cls._parse_json_data(data)\n    return cls(profile, source=source)\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.from_file_object","title":"<code>from_file_object(file_obj, source='file')</code>  <code>classmethod</code>","text":"<p>Parse a MUD profile from a file object.</p> <p>Parameters:</p> Name Type Description Default <code>file_obj</code> <code>TextIO</code> <p>File-like object to read from.</p> required <code>source</code> <code>str</code> <p>Description of the source for error messages.</p> <code>'file'</code> <p>Returns:</p> Type Description <code>'MUDParser'</code> <p>MUDParser instance with the parsed profile.</p> <p>Raises:</p> Type Description <code>MUDSchemaError</code> <p>If the JSON is malformed.</p> <code>MUDValidationError</code> <p>If the profile doesn't conform to the schema.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>@classmethod\ndef from_file_object(cls, file_obj: TextIO, source: str = \"file\") -&gt; \"MUDParser\":\n    \"\"\"\n    Parse a MUD profile from a file object.\n\n    Args:\n        file_obj: File-like object to read from.\n        source: Description of the source for error messages.\n\n    Returns:\n        MUDParser instance with the parsed profile.\n\n    Raises:\n        MUDSchemaError: If the JSON is malformed.\n        MUDValidationError: If the profile doesn't conform to the schema.\n    \"\"\"\n    try:\n        data = json.load(file_obj)\n    except json.JSONDecodeError as e:\n        raise MUDSchemaError(f\"Invalid JSON: {e}\") from e\n\n    profile = cls._parse_json_data(data)\n    return cls(profile, source=source)\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.from_url","title":"<code>from_url(url, timeout=30.0, verify_ssl=True)</code>  <code>classmethod</code>","text":"<p>Fetch and parse a MUD profile from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch the MUD profile from.</p> required <code>timeout</code> <code>float</code> <p>Request timeout in seconds.</p> <code>30.0</code> <code>verify_ssl</code> <code>bool</code> <p>Whether to verify SSL certificates.</p> <code>True</code> <p>Returns:</p> Type Description <code>'MUDParser'</code> <p>MUDParser instance with the parsed profile.</p> <p>Raises:</p> Type Description <code>MUDNetworkError</code> <p>If the request fails.</p> <code>MUDSchemaError</code> <p>If the response isn't valid JSON.</p> <code>MUDValidationError</code> <p>If the profile doesn't conform to the schema.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>@classmethod\ndef from_url(\n    cls,\n    url: str,\n    timeout: float = 30.0,\n    verify_ssl: bool = True,\n) -&gt; \"MUDParser\":\n    \"\"\"\n    Fetch and parse a MUD profile from a URL.\n\n    Args:\n        url: URL to fetch the MUD profile from.\n        timeout: Request timeout in seconds.\n        verify_ssl: Whether to verify SSL certificates.\n\n    Returns:\n        MUDParser instance with the parsed profile.\n\n    Raises:\n        MUDNetworkError: If the request fails.\n        MUDSchemaError: If the response isn't valid JSON.\n        MUDValidationError: If the profile doesn't conform to the schema.\n    \"\"\"\n    try:\n        response = httpx.get(\n            url,\n            timeout=timeout,\n            verify=verify_ssl,\n            follow_redirects=True,\n            headers={\"Accept\": \"application/mud+json, application/json\"},\n        )\n        response.raise_for_status()\n    except httpx.TimeoutException as e:\n        raise MUDNetworkError(f\"Request timed out: {e}\", url=url) from e\n    except httpx.HTTPStatusError as e:\n        raise MUDNetworkError(\n            f\"HTTP error {e.response.status_code}: {e.response.reason_phrase}\",\n            url=url,\n            status_code=e.response.status_code,\n        ) from e\n    except httpx.RequestError as e:\n        raise MUDNetworkError(f\"Network error: {e}\", url=url) from e\n\n    try:\n        data = response.json()\n    except json.JSONDecodeError as e:\n        raise MUDSchemaError(f\"Invalid JSON in response: {e}\") from e\n\n    profile = cls._parse_json_data(data)\n    return cls(profile, source=url)\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.from_url_async","title":"<code>from_url_async(url, timeout=30.0, verify_ssl=True)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Asynchronously fetch and parse a MUD profile from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch the MUD profile from.</p> required <code>timeout</code> <code>float</code> <p>Request timeout in seconds.</p> <code>30.0</code> <code>verify_ssl</code> <code>bool</code> <p>Whether to verify SSL certificates.</p> <code>True</code> <p>Returns:</p> Type Description <code>'MUDParser'</code> <p>MUDParser instance with the parsed profile.</p> <p>Raises:</p> Type Description <code>MUDNetworkError</code> <p>If the request fails.</p> <code>MUDSchemaError</code> <p>If the response isn't valid JSON.</p> <code>MUDValidationError</code> <p>If the profile doesn't conform to the schema.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>@classmethod\nasync def from_url_async(\n    cls,\n    url: str,\n    timeout: float = 30.0,\n    verify_ssl: bool = True,\n) -&gt; \"MUDParser\":\n    \"\"\"\n    Asynchronously fetch and parse a MUD profile from a URL.\n\n    Args:\n        url: URL to fetch the MUD profile from.\n        timeout: Request timeout in seconds.\n        verify_ssl: Whether to verify SSL certificates.\n\n    Returns:\n        MUDParser instance with the parsed profile.\n\n    Raises:\n        MUDNetworkError: If the request fails.\n        MUDSchemaError: If the response isn't valid JSON.\n        MUDValidationError: If the profile doesn't conform to the schema.\n    \"\"\"\n    async with httpx.AsyncClient(verify=verify_ssl) as client:\n        try:\n            response = await client.get(\n                url,\n                timeout=timeout,\n                follow_redirects=True,\n                headers={\"Accept\": \"application/mud+json, application/json\"},\n            )\n            response.raise_for_status()\n        except httpx.TimeoutException as e:\n            raise MUDNetworkError(f\"Request timed out: {e}\", url=url) from e\n        except httpx.HTTPStatusError as e:\n            raise MUDNetworkError(\n                f\"HTTP error {e.response.status_code}: {e.response.reason_phrase}\",\n                url=url,\n                status_code=e.response.status_code,\n            ) from e\n        except httpx.RequestError as e:\n            raise MUDNetworkError(f\"Network error: {e}\", url=url) from e\n\n    try:\n        data = response.json()\n    except json.JSONDecodeError as e:\n        raise MUDSchemaError(f\"Invalid JSON in response: {e}\") from e\n\n    profile = cls._parse_json_data(data)\n    return cls(profile, source=url)\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.validate","title":"<code>validate(strict=False)</code>","text":"<p>Validate the MUD profile.</p> <p>Performs semantic validation beyond the basic schema checks, including cross-reference validation and RFC compliance checks.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raise exception on first error.    If False, collect and return all errors.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of validation error messages (empty if valid).</p> <p>Raises:</p> Type Description <code>MUDValidationError</code> <p>If strict=True and validation fails.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def validate(self, strict: bool = False) -&gt; list[str]:\n    \"\"\"\n    Validate the MUD profile.\n\n    Performs semantic validation beyond the basic schema checks,\n    including cross-reference validation and RFC compliance checks.\n\n    Args:\n        strict: If True, raise exception on first error.\n               If False, collect and return all errors.\n\n    Returns:\n        List of validation error messages (empty if valid).\n\n    Raises:\n        MUDValidationError: If strict=True and validation fails.\n    \"\"\"\n    errors: list[str] = []\n\n    # Validate ACL references\n    errors.extend(self._validate_acl_references())\n\n    # Validate MUD URL format\n    errors.extend(self._validate_mud_url())\n\n    # Validate cache validity\n    errors.extend(self._validate_cache_validity())\n\n    # Validate direction-initiated usage\n    errors.extend(self._validate_direction_initiated())\n\n    if strict and errors:\n        raise MUDValidationError(\n            f\"Profile validation failed with {len(errors)} error(s)\",\n            errors=[{\"message\": e} for e in errors],\n        )\n\n    self._validated = len(errors) == 0\n    return errors\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.get_acl","title":"<code>get_acl(name)</code>","text":"<p>Get an ACL by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The ACL name to look up.</p> required <p>Returns:</p> Type Description <code>AccessControlList | None</code> <p>The ACL if found, None otherwise.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def get_acl(self, name: str) -&gt; AccessControlList | None:\n    \"\"\"\n    Get an ACL by name.\n\n    Args:\n        name: The ACL name to look up.\n\n    Returns:\n        The ACL if found, None otherwise.\n    \"\"\"\n    return self._profile.get_acl(name)\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.get_from_device_acls","title":"<code>get_from_device_acls()</code>","text":"<p>Get all ACLs for outbound (from-device) traffic.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def get_from_device_acls(self) -&gt; list[AccessControlList]:\n    \"\"\"Get all ACLs for outbound (from-device) traffic.\"\"\"\n    return self._profile.get_from_device_acls()\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.get_to_device_acls","title":"<code>get_to_device_acls()</code>","text":"<p>Get all ACLs for inbound (to-device) traffic.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def get_to_device_acls(self) -&gt; list[AccessControlList]:\n    \"\"\"Get all ACLs for inbound (to-device) traffic.\"\"\"\n    return self._profile.get_to_device_acls()\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.get_all_entries","title":"<code>get_all_entries()</code>","text":"<p>Get all ACEs from all ACLs with their direction.</p> <p>Returns:</p> Type Description <code>list[tuple[str, AccessControlEntry]]</code> <p>List of (direction, ACE) tuples.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def get_all_entries(self) -&gt; list[tuple[str, AccessControlEntry]]:\n    \"\"\"\n    Get all ACEs from all ACLs with their direction.\n\n    Returns:\n        List of (direction, ACE) tuples.\n    \"\"\"\n    entries: list[tuple[str, AccessControlEntry]] = []\n\n    for acl in self.get_from_device_acls():\n        for entry in acl.entries:\n            entries.append((\"from\", entry))\n\n    for acl in self.get_to_device_acls():\n        for entry in acl.entries:\n            entries.append((\"to\", entry))\n\n    return entries\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.get_dns_names","title":"<code>get_dns_names()</code>","text":"<p>Get all DNS names referenced in the profile.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def get_dns_names(self) -&gt; set[str]:\n    \"\"\"Get all DNS names referenced in the profile.\"\"\"\n    return self._profile.get_all_dns_names()\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.get_ports","title":"<code>get_ports()</code>","text":"<p>Get all ports referenced in the profile.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def get_ports(self) -&gt; dict[str, set[int]]:\n    \"\"\"Get all ports referenced in the profile.\"\"\"\n    return self._profile.get_all_ports()\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.print_rules","title":"<code>print_rules()</code>","text":"<p>Print all rules in human-readable format.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def print_rules(self) -&gt; None:\n    \"\"\"Print all rules in human-readable format.\"\"\"\n    print(self._profile.print_rules())\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the profile to a dictionary.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the profile to a dictionary.\"\"\"\n    return self._profile.to_dict()\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.to_json","title":"<code>to_json(indent=2)</code>","text":"<p>Convert the profile to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>JSON indentation level.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>JSON string representation.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def to_json(self, indent: int = 2) -&gt; str:\n    \"\"\"\n    Convert the profile to a JSON string.\n\n    Args:\n        indent: JSON indentation level.\n\n    Returns:\n        JSON string representation.\n    \"\"\"\n    return json.dumps(self.to_dict(), indent=indent, default=str)\n</code></pre>"},{"location":"api-reference/parser/#mudparser.parser.MUDParser.get_summary","title":"<code>get_summary()</code>","text":"<p>Get a summary of the MUD profile.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with profile summary information.</p> Source code in <code>src/mudparser/parser.py</code> <pre><code>def get_summary(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get a summary of the MUD profile.\n\n    Returns:\n        Dictionary with profile summary information.\n    \"\"\"\n    return {\n        \"url\": str(self._profile.mud.mud_url),\n        \"version\": self._profile.mud.mud_version,\n        \"systeminfo\": self._profile.mud.systeminfo,\n        \"last_update\": self._profile.mud.last_update.isoformat(),\n        \"cache_validity_hours\": self._profile.mud.cache_validity,\n        \"is_supported\": self._profile.mud.is_supported,\n        \"manufacturer\": self._profile.mud.mfg_name,\n        \"model\": self._profile.mud.model_name,\n        \"total_acls\": len(self._profile.acls.acl),\n        \"from_device_acls\": len(self.get_from_device_acls()),\n        \"to_device_acls\": len(self.get_to_device_acls()),\n        \"from_device_rules\": sum(len(acl.entries) for acl in self.get_from_device_acls()),\n        \"to_device_rules\": sum(len(acl.entries) for acl in self.get_to_device_acls()),\n        \"total_rules\": sum(len(acl.entries) for acl in self._profile.acls.acl),\n        \"dns_names\": list(self.get_dns_names()),\n        \"ports\": {k: list(v) for k, v in self.get_ports().items()},\n        \"source\": self._source,\n    }\n</code></pre>"},{"location":"api-reference/validator/","title":"Validator API Reference","text":""},{"location":"api-reference/validator/#mudparser.validator.MUDValidator","title":"<code>mudparser.validator.MUDValidator</code>","text":"<p>Validator for MUD profiles.</p> <p>Provides comprehensive validation including: - Structure validation (required fields, types) - Cross-reference validation (ACL references) - RFC compliance validation - Best practice checks</p> Example <p>validator = MUDValidator() result = validator.validate(profile) if not result.is_valid: ...     for error in result.errors: ...         print(f\"Error: {error.message}\")</p> Source code in <code>src/mudparser/validator.py</code> <pre><code>class MUDValidator:\n    \"\"\"\n    Validator for MUD profiles.\n\n    Provides comprehensive validation including:\n    - Structure validation (required fields, types)\n    - Cross-reference validation (ACL references)\n    - RFC compliance validation\n    - Best practice checks\n\n    Example:\n        &gt;&gt;&gt; validator = MUDValidator()\n        &gt;&gt;&gt; result = validator.validate(profile)\n        &gt;&gt;&gt; if not result.is_valid:\n        ...     for error in result.errors:\n        ...         print(f\"Error: {error.message}\")\n    \"\"\"\n\n    # Standard MUD controller URNs (RFC 8520 Section 8.3)\n    STANDARD_CONTROLLER_URNS = {\n        \"urn:ietf:params:mud:dns\",\n        \"urn:ietf:params:mud:ntp\",\n    }\n\n    def __init__(self, strict: bool = False) -&gt; None:\n        \"\"\"\n        Initialize the validator.\n\n        Args:\n            strict: If True, treat warnings as errors.\n        \"\"\"\n        self.strict = strict\n\n    def validate(self, profile: MUDProfile) -&gt; ValidationResult:\n        \"\"\"\n        Validate a MUD profile.\n\n        Args:\n            profile: The MUD profile to validate.\n\n        Returns:\n            ValidationResult with all issues found.\n        \"\"\"\n        issues: list[ValidationIssue] = []\n\n        # Run all validation checks\n        issues.extend(self._validate_mud_container(profile))\n        issues.extend(self._validate_acl_references(profile))\n        issues.extend(self._validate_acl_types(profile))\n        issues.extend(self._validate_ace_matches(profile))\n        issues.extend(self._validate_mud_matches(profile))\n        issues.extend(self._validate_best_practices(profile))\n\n        # Determine validity\n        if self.strict:\n            is_valid = len(issues) == 0\n        else:\n            is_valid = all(i.severity != ValidationSeverity.ERROR for i in issues)\n\n        return ValidationResult(\n            is_valid=is_valid,\n            issues=issues,\n            profile=profile,\n        )\n\n    def validate_json(self, data: dict[str, Any]) -&gt; ValidationResult:\n        \"\"\"\n        Validate raw JSON data.\n\n        Performs structure validation before attempting to parse\n        into a MUDProfile.\n\n        Args:\n            data: Raw JSON data to validate.\n\n        Returns:\n            ValidationResult with all issues found.\n        \"\"\"\n        issues: list[ValidationIssue] = []\n\n        # Check required top-level containers\n        if \"ietf-mud:mud\" not in data:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.ERROR,\n                message=\"Missing required 'ietf-mud:mud' container\",\n                path=\"$\",\n                code=\"MISSING_MUD_CONTAINER\",\n            ))\n\n        if \"ietf-access-control-list:access-lists\" not in data:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.ERROR,\n                message=\"Missing required 'ietf-access-control-list:access-lists' container\",\n                path=\"$\",\n                code=\"MISSING_ACL_CONTAINER\",\n            ))\n\n        # If structural issues, return early\n        if issues:\n            return ValidationResult(is_valid=False, issues=issues)\n\n        # Try to parse and validate\n        try:\n            profile = MUDProfile.from_json(data)\n            return self.validate(profile)\n        except (ValueError, KeyError) as e:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.ERROR,\n                message=str(e),\n                code=\"PARSE_ERROR\",\n            ))\n            return ValidationResult(is_valid=False, issues=issues)\n\n    def _validate_mud_container(self, profile: MUDProfile) -&gt; list[ValidationIssue]:\n        \"\"\"Validate the MUD container fields.\"\"\"\n        issues: list[ValidationIssue] = []\n        mud = profile.mud\n\n        # Validate MUD version\n        if mud.mud_version != 1:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.ERROR,\n                message=f\"Unsupported MUD version: {mud.mud_version}\",\n                path=\"$.ietf-mud:mud.mud-version\",\n                code=\"UNSUPPORTED_VERSION\",\n                details={\"version\": mud.mud_version, \"supported\": [1]},\n            ))\n\n        # Validate MUD URL scheme\n        url = str(mud.mud_url)\n        if not url.startswith(\"https://\"):\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.WARNING,\n                message=f\"MUD URL should use HTTPS: {url}\",\n                path=\"$.ietf-mud:mud.mud-url\",\n                code=\"HTTP_MUD_URL\",\n            ))\n\n        # Validate cache validity range\n        if not 1 &lt;= mud.cache_validity &lt;= 168:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.ERROR,\n                message=f\"Cache validity {mud.cache_validity} outside valid range (1-168)\",\n                path=\"$.ietf-mud:mud.cache-validity\",\n                code=\"INVALID_CACHE_VALIDITY\",\n                details={\"value\": mud.cache_validity, \"min\": 1, \"max\": 168},\n            ))\n\n        # Validate systeminfo length\n        if mud.systeminfo and len(mud.systeminfo) &gt; 60:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.ERROR,\n                message=f\"System info exceeds 60 character limit: {len(mud.systeminfo)}\",\n                path=\"$.ietf-mud:mud.systeminfo\",\n                code=\"SYSTEMINFO_TOO_LONG\",\n            ))\n\n        return issues\n\n    def _validate_acl_references(self, profile: MUDProfile) -&gt; list[ValidationIssue]:\n        \"\"\"Validate that all ACL references can be resolved.\"\"\"\n        issues: list[ValidationIssue] = []\n        acl_names = {acl.name for acl in profile.acls.acl}\n\n        # Check from-device-policy references\n        for acl_ref in profile.mud.from_device_policy.access_lists.access_list:\n            if acl_ref.name not in acl_names:\n                issues.append(ValidationIssue(\n                    severity=ValidationSeverity.ERROR,\n                    message=f\"ACL '{acl_ref.name}' not found in access-lists\",\n                    path=\"$.ietf-mud:mud.from-device-policy\",\n                    code=\"MISSING_ACL_REFERENCE\",\n                    details={\"acl_name\": acl_ref.name, \"policy\": \"from-device-policy\"},\n                ))\n\n        # Check to-device-policy references\n        for acl_ref in profile.mud.to_device_policy.access_lists.access_list:\n            if acl_ref.name not in acl_names:\n                issues.append(ValidationIssue(\n                    severity=ValidationSeverity.ERROR,\n                    message=f\"ACL '{acl_ref.name}' not found in access-lists\",\n                    path=\"$.ietf-mud:mud.to-device-policy\",\n                    code=\"MISSING_ACL_REFERENCE\",\n                    details={\"acl_name\": acl_ref.name, \"policy\": \"to-device-policy\"},\n                ))\n\n        # Check for unreferenced ACLs\n        referenced = set()\n        for ref in profile.mud.from_device_policy.access_lists.access_list:\n            referenced.add(ref.name)\n        for ref in profile.mud.to_device_policy.access_lists.access_list:\n            referenced.add(ref.name)\n\n        for acl in profile.acls.acl:\n            if acl.name not in referenced:\n                issues.append(ValidationIssue(\n                    severity=ValidationSeverity.WARNING,\n                    message=f\"ACL '{acl.name}' is not referenced by any policy\",\n                    path=f\"$.ietf-access-control-list:access-lists.acl[name='{acl.name}']\",\n                    code=\"UNREFERENCED_ACL\",\n                ))\n\n        return issues\n\n    def _validate_acl_types(self, profile: MUDProfile) -&gt; list[ValidationIssue]:\n        \"\"\"Validate ACL type consistency.\"\"\"\n        issues: list[ValidationIssue] = []\n\n        for acl in profile.acls.acl:\n            for entry in acl.entries:\n                # Check IPv4 ACL has IPv4 matches\n                if acl.is_ipv4() and entry.matches.ipv6:\n                    issues.append(ValidationIssue(\n                        severity=ValidationSeverity.WARNING,\n                        message=f\"IPv6 match in IPv4 ACL '{acl.name}'\",\n                        path=f\"$.ietf-access-control-list:access-lists.acl[name='{acl.name}']\",\n                        code=\"ACL_TYPE_MISMATCH\",\n                    ))\n\n                # Check IPv6 ACL has IPv6 matches\n                if acl.is_ipv6() and entry.matches.ipv4:\n                    issues.append(ValidationIssue(\n                        severity=ValidationSeverity.WARNING,\n                        message=f\"IPv4 match in IPv6 ACL '{acl.name}'\",\n                        path=f\"$.ietf-access-control-list:access-lists.acl[name='{acl.name}']\",\n                        code=\"ACL_TYPE_MISMATCH\",\n                    ))\n\n        return issues\n\n    def _validate_ace_matches(self, profile: MUDProfile) -&gt; list[ValidationIssue]:\n        \"\"\"Validate ACE match conditions.\"\"\"\n        issues: list[ValidationIssue] = []\n\n        for acl in profile.acls.acl:\n            for entry in acl.entries:\n                matches = entry.matches\n\n                # direction-initiated only valid for TCP\n                if matches.tcp and matches.tcp.direction_initiated:\n                    pass  # Valid\n                elif matches.udp:\n                    # UDP shouldn't have direction-initiated\n                    # (handled by Pydantic, but double-check)\n                    pass\n\n                # Check for empty matches\n                if not matches.has_matches():\n                    issues.append(ValidationIssue(\n                        severity=ValidationSeverity.WARNING,\n                        message=f\"ACE '{entry.name}' has no match conditions\",\n                        path=f\"$.ietf-access-control-list:access-lists.acl[name='{acl.name}'].aces.ace[name='{entry.name}']\",\n                        code=\"EMPTY_MATCHES\",\n                    ))\n\n                # Validate port ranges\n                for port_match in [matches.tcp, matches.udp]:\n                    if port_match:\n                        for port_field in ['src_port', 'dst_port']:\n                            port = getattr(port_match, port_field, None)\n                            if port and port.upper_port:\n                                if port.upper_port &lt;= port.port:\n                                    issues.append(ValidationIssue(\n                                        severity=ValidationSeverity.ERROR,\n                                        message=f\"Invalid port range in {entry.name}: {port.port}-{port.upper_port}\",\n                                        code=\"INVALID_PORT_RANGE\",\n                                    ))\n\n        return issues\n\n    def _validate_mud_matches(self, profile: MUDProfile) -&gt; list[ValidationIssue]:\n        \"\"\"Validate MUD-specific match conditions.\"\"\"\n        issues: list[ValidationIssue] = []\n\n        for acl in profile.acls.acl:\n            for entry in acl.entries:\n                if entry.matches.mud:\n                    mud_match = entry.matches.mud\n                    match_type = mud_match.get_match_type()\n\n                    # Validate controller URN format\n                    if match_type == \"controller\" and mud_match.controller:\n                        controller = mud_match.controller\n                        if controller.startswith(\"urn:\"):\n                            if controller not in self.STANDARD_CONTROLLER_URNS:\n                                issues.append(ValidationIssue(\n                                    severity=ValidationSeverity.INFO,\n                                    message=f\"Non-standard controller URN: {controller}\",\n                                    path=f\"$.ietf-access-control-list:access-lists.acl.aces.ace[name='{entry.name}']\",\n                                    code=\"NONSTANDARD_CONTROLLER_URN\",\n                                ))\n\n        return issues\n\n    def _validate_best_practices(self, profile: MUDProfile) -&gt; list[ValidationIssue]:\n        \"\"\"Check for best practice violations.\"\"\"\n        issues: list[ValidationIssue] = []\n\n        # Check for deprecated device\n        if not profile.mud.is_supported:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.INFO,\n                message=\"Device is marked as no longer supported\",\n                path=\"$.ietf-mud:mud.is-supported\",\n                code=\"DEVICE_UNSUPPORTED\",\n            ))\n\n        # Check for missing manufacturer info\n        if not profile.mud.mfg_name:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.INFO,\n                message=\"Manufacturer name not specified\",\n                path=\"$.ietf-mud:mud\",\n                code=\"MISSING_MFG_NAME\",\n            ))\n\n        # Check for missing documentation URL\n        if not profile.mud.documentation:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.INFO,\n                message=\"No documentation URL provided\",\n                path=\"$.ietf-mud:mud\",\n                code=\"MISSING_DOCUMENTATION\",\n            ))\n\n        # Warn about large cache validity\n        if profile.mud.cache_validity &gt; 24:\n            issues.append(ValidationIssue(\n                severity=ValidationSeverity.INFO,\n                message=f\"Cache validity is {profile.mud.cache_validity} hours; consider more frequent updates\",\n                path=\"$.ietf-mud:mud.cache-validity\",\n                code=\"LARGE_CACHE_VALIDITY\",\n            ))\n\n        return issues\n</code></pre>"},{"location":"api-reference/validator/#mudparser.validator.MUDValidator.__init__","title":"<code>__init__(strict=False)</code>","text":"<p>Initialize the validator.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, treat warnings as errors.</p> <code>False</code> Source code in <code>src/mudparser/validator.py</code> <pre><code>def __init__(self, strict: bool = False) -&gt; None:\n    \"\"\"\n    Initialize the validator.\n\n    Args:\n        strict: If True, treat warnings as errors.\n    \"\"\"\n    self.strict = strict\n</code></pre>"},{"location":"api-reference/validator/#mudparser.validator.MUDValidator.validate","title":"<code>validate(profile)</code>","text":"<p>Validate a MUD profile.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>MUDProfile</code> <p>The MUD profile to validate.</p> required <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult with all issues found.</p> Source code in <code>src/mudparser/validator.py</code> <pre><code>def validate(self, profile: MUDProfile) -&gt; ValidationResult:\n    \"\"\"\n    Validate a MUD profile.\n\n    Args:\n        profile: The MUD profile to validate.\n\n    Returns:\n        ValidationResult with all issues found.\n    \"\"\"\n    issues: list[ValidationIssue] = []\n\n    # Run all validation checks\n    issues.extend(self._validate_mud_container(profile))\n    issues.extend(self._validate_acl_references(profile))\n    issues.extend(self._validate_acl_types(profile))\n    issues.extend(self._validate_ace_matches(profile))\n    issues.extend(self._validate_mud_matches(profile))\n    issues.extend(self._validate_best_practices(profile))\n\n    # Determine validity\n    if self.strict:\n        is_valid = len(issues) == 0\n    else:\n        is_valid = all(i.severity != ValidationSeverity.ERROR for i in issues)\n\n    return ValidationResult(\n        is_valid=is_valid,\n        issues=issues,\n        profile=profile,\n    )\n</code></pre>"},{"location":"api-reference/validator/#mudparser.validator.MUDValidator.validate_json","title":"<code>validate_json(data)</code>","text":"<p>Validate raw JSON data.</p> <p>Performs structure validation before attempting to parse into a MUDProfile.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Raw JSON data to validate.</p> required <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult with all issues found.</p> Source code in <code>src/mudparser/validator.py</code> <pre><code>def validate_json(self, data: dict[str, Any]) -&gt; ValidationResult:\n    \"\"\"\n    Validate raw JSON data.\n\n    Performs structure validation before attempting to parse\n    into a MUDProfile.\n\n    Args:\n        data: Raw JSON data to validate.\n\n    Returns:\n        ValidationResult with all issues found.\n    \"\"\"\n    issues: list[ValidationIssue] = []\n\n    # Check required top-level containers\n    if \"ietf-mud:mud\" not in data:\n        issues.append(ValidationIssue(\n            severity=ValidationSeverity.ERROR,\n            message=\"Missing required 'ietf-mud:mud' container\",\n            path=\"$\",\n            code=\"MISSING_MUD_CONTAINER\",\n        ))\n\n    if \"ietf-access-control-list:access-lists\" not in data:\n        issues.append(ValidationIssue(\n            severity=ValidationSeverity.ERROR,\n            message=\"Missing required 'ietf-access-control-list:access-lists' container\",\n            path=\"$\",\n            code=\"MISSING_ACL_CONTAINER\",\n        ))\n\n    # If structural issues, return early\n    if issues:\n        return ValidationResult(is_valid=False, issues=issues)\n\n    # Try to parse and validate\n    try:\n        profile = MUDProfile.from_json(data)\n        return self.validate(profile)\n    except (ValueError, KeyError) as e:\n        issues.append(ValidationIssue(\n            severity=ValidationSeverity.ERROR,\n            message=str(e),\n            code=\"PARSE_ERROR\",\n        ))\n        return ValidationResult(is_valid=False, issues=issues)\n</code></pre>"},{"location":"api-reference/validator/#mudparser.validator.ValidationResult","title":"<code>mudparser.validator.ValidationResult</code>  <code>dataclass</code>","text":"<p>Result of profile validation.</p> <p>Attributes:</p> Name Type Description <code>is_valid</code> <code>bool</code> <p>Whether the profile passes validation.</p> <code>issues</code> <code>list[ValidationIssue]</code> <p>List of validation issues found.</p> <code>profile</code> <code>MUDProfile | None</code> <p>The validated profile (if parsing succeeded).</p> Source code in <code>src/mudparser/validator.py</code> <pre><code>@dataclass\nclass ValidationResult:\n    \"\"\"\n    Result of profile validation.\n\n    Attributes:\n        is_valid: Whether the profile passes validation.\n        issues: List of validation issues found.\n        profile: The validated profile (if parsing succeeded).\n    \"\"\"\n\n    is_valid: bool\n    issues: list[ValidationIssue] = field(default_factory=list)\n    profile: MUDProfile | None = None\n\n    @property\n    def errors(self) -&gt; list[ValidationIssue]:\n        \"\"\"Get only error-level issues.\"\"\"\n        return [i for i in self.issues if i.severity == ValidationSeverity.ERROR]\n\n    @property\n    def warnings(self) -&gt; list[ValidationIssue]:\n        \"\"\"Get only warning-level issues.\"\"\"\n        return [i for i in self.issues if i.severity == ValidationSeverity.WARNING]\n\n    @property\n    def error_count(self) -&gt; int:\n        \"\"\"Get the number of errors.\"\"\"\n        return len(self.errors)\n\n    @property\n    def warning_count(self) -&gt; int:\n        \"\"\"Get the number of warnings.\"\"\"\n        return len(self.warnings)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert to dictionary representation.\"\"\"\n        return {\n            \"is_valid\": self.is_valid,\n            \"error_count\": self.error_count,\n            \"warning_count\": self.warning_count,\n            \"issues\": [issue.to_dict() for issue in self.issues],\n        }\n</code></pre>"},{"location":"api-reference/validator/#mudparser.validator.ValidationResult.error_count","title":"<code>error_count</code>  <code>property</code>","text":"<p>Get the number of errors.</p>"},{"location":"api-reference/validator/#mudparser.validator.ValidationResult.errors","title":"<code>errors</code>  <code>property</code>","text":"<p>Get only error-level issues.</p>"},{"location":"api-reference/validator/#mudparser.validator.ValidationResult.warning_count","title":"<code>warning_count</code>  <code>property</code>","text":"<p>Get the number of warnings.</p>"},{"location":"api-reference/validator/#mudparser.validator.ValidationResult.warnings","title":"<code>warnings</code>  <code>property</code>","text":"<p>Get only warning-level issues.</p>"},{"location":"api-reference/validator/#mudparser.validator.ValidationResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary representation.</p> Source code in <code>src/mudparser/validator.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to dictionary representation.\"\"\"\n    return {\n        \"is_valid\": self.is_valid,\n        \"error_count\": self.error_count,\n        \"warning_count\": self.warning_count,\n        \"issues\": [issue.to_dict() for issue in self.issues],\n    }\n</code></pre>"},{"location":"api-reference/validator/#mudparser.validator.ValidationIssue","title":"<code>mudparser.validator.ValidationIssue</code>  <code>dataclass</code>","text":"<p>A single validation issue.</p> <p>Attributes:</p> Name Type Description <code>severity</code> <code>ValidationSeverity</code> <p>The severity level of the issue.</p> <code>message</code> <code>str</code> <p>Human-readable description of the issue.</p> <code>path</code> <code>str | None</code> <p>JSON path to the problematic element (if applicable).</p> <code>code</code> <code>str | None</code> <p>Machine-readable error code.</p> <code>details</code> <code>dict[str, Any]</code> <p>Additional context about the issue.</p> Source code in <code>src/mudparser/validator.py</code> <pre><code>@dataclass\nclass ValidationIssue:\n    \"\"\"\n    A single validation issue.\n\n    Attributes:\n        severity: The severity level of the issue.\n        message: Human-readable description of the issue.\n        path: JSON path to the problematic element (if applicable).\n        code: Machine-readable error code.\n        details: Additional context about the issue.\n    \"\"\"\n\n    severity: ValidationSeverity\n    message: str\n    path: str | None = None\n    code: str | None = None\n    details: dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert to dictionary representation.\"\"\"\n        result = {\n            \"severity\": self.severity.value,\n            \"message\": self.message,\n        }\n        if self.path:\n            result[\"path\"] = self.path\n        if self.code:\n            result[\"code\"] = self.code\n        if self.details:\n            result[\"details\"] = self.details\n        return result\n</code></pre>"},{"location":"api-reference/validator/#mudparser.validator.ValidationIssue.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary representation.</p> Source code in <code>src/mudparser/validator.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to dictionary representation.\"\"\"\n    result = {\n        \"severity\": self.severity.value,\n        \"message\": self.message,\n    }\n    if self.path:\n        result[\"path\"] = self.path\n    if self.code:\n        result[\"code\"] = self.code\n    if self.details:\n        result[\"details\"] = self.details\n    return result\n</code></pre>"},{"location":"api-reference/validator/#mudparser.validator.ValidationSeverity","title":"<code>mudparser.validator.ValidationSeverity</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Severity levels for validation issues.</p> Source code in <code>src/mudparser/validator.py</code> <pre><code>class ValidationSeverity(str, Enum):\n    \"\"\"Severity levels for validation issues.\"\"\"\n\n    ERROR = \"error\"  # Must be fixed - profile is invalid\n    WARNING = \"warning\"  # Should be fixed - potential issues\n    INFO = \"info\"  # Informational - best practice suggestions\n</code></pre>"},{"location":"examples/basic-parsing/","title":"Basic Parsing Examples","text":""},{"location":"examples/basic-parsing/#parse-and-display-profile-info","title":"Parse and Display Profile Info","text":"<pre><code>from mudparser import MUDParser\n\n# Parse the profile\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Display basic info\nprint(f\"Device: {parser.mud.systeminfo}\")\nprint(f\"MUD URL: {parser.mud.mud_url}\")\nprint(f\"Version: {parser.mud.mud_version}\")\nprint(f\"Supported: {parser.mud.is_supported}\")\nprint(f\"Cache Validity: {parser.mud.cache_validity} hours\")\n</code></pre>"},{"location":"examples/basic-parsing/#list-all-acls-and-rules","title":"List All ACLs and Rules","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Iterate over all ACLs\nfor acl in parser.profile.acls.acl:\n    print(f\"\\nACL: {acl.name}\")\n    print(f\"Type: {acl.acl_type.value}\")\n    print(f\"Entries: {len(acl)}\")\n\n    for entry in acl.entries:\n        action = \"ALLOW\" if entry.is_accept() else \"DENY\"\n        print(f\"  - [{action}] {entry.name}\")\n</code></pre>"},{"location":"examples/basic-parsing/#extract-network-resources","title":"Extract Network Resources","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Get all DNS names\ndns_names = parser.get_dns_names()\nprint(\"DNS Names:\")\nfor name in sorted(dns_names):\n    print(f\"  - {name}\")\n\n# Get all ports\nports = parser.get_ports()\nprint(\"\\nTCP Ports:\", sorted(ports[\"tcp\"]))\nprint(\"UDP Ports:\", sorted(ports[\"udp\"]))\n</code></pre>"},{"location":"examples/basic-parsing/#analyze-policies-by-direction","title":"Analyze Policies by Direction","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# From-device (outbound) ACLs\nprint(\"=== OUTBOUND POLICIES ===\")\nfor acl in parser.get_from_device_acls():\n    print(f\"\\n{acl.name}:\")\n    for entry in acl.entries:\n        desc = entry.get_description(direction=\"from\")\n        print(f\"  {desc}\")\n\n# To-device (inbound) ACLs\nprint(\"\\n=== INBOUND POLICIES ===\")\nfor acl in parser.get_to_device_acls():\n    print(f\"\\n{acl.name}:\")\n    for entry in acl.entries:\n        desc = entry.get_description(direction=\"to\")\n        print(f\"  {desc}\")\n</code></pre>"},{"location":"examples/basic-parsing/#check-match-details","title":"Check Match Details","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\nfor direction, entry in parser.get_all_entries():\n    print(f\"\\n[{direction.upper()}] {entry.name}\")\n\n    matches = entry.matches\n\n    # IPv4 matches\n    if matches.ipv4:\n        print(f\"  IPv4 Protocol: {matches.ipv4.protocol}\")\n        if matches.ipv4.dst_dnsname:\n            print(f\"  Destination: {matches.ipv4.dst_dnsname}\")\n\n    # TCP matches\n    if matches.tcp:\n        if matches.tcp.dst_port:\n            print(f\"  Dest Port: {matches.tcp.dst_port}\")\n        if matches.tcp.direction_initiated:\n            print(f\"  Direction: {matches.tcp.direction_initiated.value}\")\n\n    # MUD matches\n    if matches.mud:\n        match_type = matches.mud.get_match_type()\n        print(f\"  MUD Match: {match_type}\")\n</code></pre>"},{"location":"examples/basic-parsing/#validate-and-report","title":"Validate and Report","text":"<pre><code>from mudparser import MUDParser\nfrom mudparser.validator import MUDValidator, ValidationSeverity\n\nparser = MUDParser.from_file(\"device.mud.json\")\nvalidator = MUDValidator()\n\nresult = validator.validate(parser.profile)\n\nprint(f\"Valid: {result.is_valid}\")\nprint(f\"Errors: {result.error_count}\")\nprint(f\"Warnings: {result.warning_count}\")\n\nif result.issues:\n    print(\"\\nIssues found:\")\n    for issue in result.issues:\n        severity = issue.severity.value.upper()\n        print(f\"  [{severity}] {issue.message}\")\n</code></pre>"},{"location":"examples/basic-parsing/#convert-between-formats","title":"Convert Between Formats","text":"<pre><code>from mudparser import MUDParser\nimport json\n\n# Parse from file\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Convert to dictionary\ndata = parser.to_dict()\n\n# Convert to JSON string\njson_str = parser.to_json(indent=2)\n\n# Convert to YAML\nyaml_str = parser.export.to_yaml()\n\n# Parse from string\nparser2 = MUDParser.from_string(json_str)\n\n# Parse from dict\nparser3 = MUDParser.from_dict(data)\n</code></pre>"},{"location":"examples/basic-parsing/#async-url-fetching","title":"Async URL Fetching","text":"<pre><code>import asyncio\nfrom mudparser import MUDParser\n\nasync def fetch_multiple_profiles(urls):\n    profiles = []\n    for url in urls:\n        try:\n            parser = await MUDParser.from_url_async(url)\n            profiles.append(parser)\n            print(f\"Fetched: {parser.mud.systeminfo}\")\n        except Exception as e:\n            print(f\"Failed to fetch {url}: {e}\")\n    return profiles\n\n# Run async\nurls = [\n    \"https://example.com/device1.mud.json\",\n    \"https://example.com/device2.mud.json\",\n]\nprofiles = asyncio.run(fetch_multiple_profiles(urls))\n</code></pre>"},{"location":"examples/basic-parsing/#error-handling","title":"Error Handling","text":"<pre><code>from mudparser import MUDParser\nfrom mudparser.exceptions import (\n    MUDFileNotFoundError,\n    MUDSchemaError,\n    MUDValidationError,\n    MUDNetworkError,\n)\n\ndef safe_parse(source):\n    try:\n        if source.startswith(\"http\"):\n            return MUDParser.from_url(source)\n        else:\n            return MUDParser.from_file(source)\n    except MUDFileNotFoundError as e:\n        print(f\"File not found: {e.file_path}\")\n    except MUDSchemaError as e:\n        print(f\"Invalid JSON: {e.message}\")\n    except MUDNetworkError as e:\n        print(f\"Network error: {e.message}\")\n        if e.status_code:\n            print(f\"HTTP Status: {e.status_code}\")\n    except MUDValidationError as e:\n        print(f\"Validation error: {e.message}\")\n    return None\n\n# Usage\nparser = safe_parse(\"device.mud.json\")\nif parser:\n    print(f\"Loaded: {parser.mud.systeminfo}\")\n</code></pre>"},{"location":"examples/firewall-generation/","title":"Firewall Generation Examples","text":""},{"location":"examples/firewall-generation/#generate-iptables-rules","title":"Generate iptables Rules","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Generate iptables rules\nrules = parser.export.to_iptables(\n    device_ip=\"192.168.1.100\",\n    device_interface=\"eth0\",\n    chain_prefix=\"IOT\",\n    include_comments=True,\n)\n\nprint(rules)\n\n# Save to file\nwith open(\"iot_rules.sh\", \"w\") as f:\n    f.write(rules)\n</code></pre>"},{"location":"examples/firewall-generation/#generate-nftables-rules","title":"Generate nftables Rules","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Generate nftables configuration\nrules = parser.export.to_nftables(\n    device_ip=\"192.168.1.100\",\n    table_name=\"iot_rules\",\n)\n\n# Save to file\nwith open(\"iot_rules.nft\", \"w\") as f:\n    f.write(rules)\n\n# Apply: nft -f iot_rules.nft\n</code></pre>"},{"location":"examples/firewall-generation/#generate-cisco-acls","title":"Generate Cisco ACLs","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Generate Cisco IOS ACLs\nacls = parser.export.to_cisco_acl(\n    acl_number_start=100,\n    include_remarks=True,\n)\n\nprint(acls)\n</code></pre>"},{"location":"examples/firewall-generation/#generate-pfsense-rules","title":"Generate pfSense Rules","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Generate pfSense XML\nxml_rules = parser.export.to_pfsense(\n    device_ip=\"192.168.1.100\",\n    interface=\"lan\",\n)\n\n# Save to file for import\nwith open(\"pfsense_rules.xml\", \"w\") as f:\n    f.write(xml_rules)\n</code></pre>"},{"location":"examples/firewall-generation/#batch-processing-multiple-devices","title":"Batch Processing Multiple Devices","text":"<pre><code>from mudparser import MUDParser\nfrom pathlib import Path\n\ndevices = [\n    {\"file\": \"echo.mud.json\", \"ip\": \"192.168.1.100\"},\n    {\"file\": \"camera.mud.json\", \"ip\": \"192.168.1.101\"},\n    {\"file\": \"thermostat.mud.json\", \"ip\": \"192.168.1.102\"},\n]\n\nall_rules = [\"#!/bin/bash\", \"# IoT Firewall Rules\", \"\"]\n\nfor device in devices:\n    parser = MUDParser.from_file(device[\"file\"])\n    rules = parser.export.to_iptables(device_ip=device[\"ip\"])\n\n    # Extract just the rules (skip header)\n    lines = rules.split(\"\\n\")\n    rule_lines = [l for l in lines if l.startswith(\"iptables\")]\n    all_rules.extend(rule_lines)\n    all_rules.append(\"\")\n\n# Save combined rules\nwith open(\"all_iot_rules.sh\", \"w\") as f:\n    f.write(\"\\n\".join(all_rules))\n</code></pre>"},{"location":"examples/firewall-generation/#export-with-dns-resolution","title":"Export with DNS Resolution","text":"<pre><code>import socket\nfrom mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Get DNS names that need resolution\ndns_names = parser.get_dns_names()\n\n# Resolve DNS names\nip_mapping = {}\nfor name in dns_names:\n    try:\n        ip = socket.gethostbyname(name)\n        ip_mapping[name] = ip\n        print(f\"Resolved {name} -&gt; {ip}\")\n    except socket.gaierror:\n        print(f\"Could not resolve {name}\")\n\n# Generate rules (DNS names will be in rules as-is)\nrules = parser.export.to_iptables(device_ip=\"192.168.1.100\")\n\n# Optionally replace DNS names with IPs\nfor name, ip in ip_mapping.items():\n    rules = rules.replace(f\"-d {name}\", f\"-d {ip}\")\n    rules = rules.replace(f\"-s {name}\", f\"-s {ip}\")\n\nprint(rules)\n</code></pre>"},{"location":"examples/firewall-generation/#generate-rules-for-multiple-formats","title":"Generate Rules for Multiple Formats","text":"<pre><code>from mudparser import MUDParser\nfrom pathlib import Path\n\nparser = MUDParser.from_file(\"device.mud.json\")\ndevice_ip = \"192.168.1.100\"\noutput_dir = Path(\"firewall_rules\")\noutput_dir.mkdir(exist_ok=True)\n\n# Generate all formats\nformats = {\n    \"iptables\": (\"rules.sh\", {\"device_ip\": device_ip}),\n    \"nftables\": (\"rules.nft\", {\"device_ip\": device_ip}),\n    \"cisco\": (\"rules.ios\", {}),\n    \"pfsense\": (\"rules.xml\", {\"device_ip\": device_ip}),\n}\n\nfor format_name, (filename, kwargs) in formats.items():\n    rules = parser.export.export(format_name, **kwargs)\n    output_path = output_dir / filename\n    output_path.write_text(rules)\n    print(f\"Generated {output_path}\")\n</code></pre>"},{"location":"examples/firewall-generation/#conditional-rule-generation","title":"Conditional Rule Generation","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Get summary to decide on generation\nsummary = parser.export.get_summary()\n\nprint(f\"Device: {summary['device_info']}\")\nprint(f\"Total rules: {summary['total_rules']}\")\n\n# Only generate if there are rules\nif summary['total_rules'] &gt; 0:\n    rules = parser.export.to_iptables(device_ip=\"192.168.1.100\")\n\n    # Check for specific ports\n    if 443 in summary['ports']['tcp']:\n        print(\"Note: Device uses HTTPS\")\n\n    if 53 in summary['ports']['udp']:\n        print(\"Note: Device uses DNS\")\nelse:\n    print(\"No rules to generate\")\n</code></pre>"},{"location":"examples/firewall-generation/#cli-based-generation","title":"CLI-Based Generation","text":"<pre><code># Generate iptables rules\nmudparser export device.mud.json -f iptables -d 192.168.1.100 &gt; rules.sh\n\n# Generate nftables rules\nmudparser export device.mud.json -f nftables -d 192.168.1.100 -o rules.nft\n\n# Generate Cisco ACL\nmudparser export device.mud.json -f cisco &gt; device.acl\n\n# Generate pfSense XML\nmudparser export device.mud.json -f pfsense -d 192.168.1.100 -o pfsense_import.xml\n</code></pre>"},{"location":"examples/firewall-generation/#integration-script","title":"Integration Script","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nGenerate and optionally apply firewall rules from MUD profile.\n\"\"\"\n\nimport argparse\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nfrom mudparser import MUDParser\nfrom mudparser.validator import MUDValidator\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Generate firewall rules from MUD\")\n    parser.add_argument(\"mud_file\", help=\"MUD profile file\")\n    parser.add_argument(\"--device-ip\", required=True, help=\"Device IP address\")\n    parser.add_argument(\"--format\", choices=[\"iptables\", \"nftables\"], default=\"iptables\")\n    parser.add_argument(\"--apply\", action=\"store_true\", help=\"Apply rules immediately\")\n    parser.add_argument(\"--output\", help=\"Output file\")\n\n    args = parser.parse_args()\n\n    # Parse and validate\n    mud_parser = MUDParser.from_file(args.mud_file)\n    validator = MUDValidator()\n    result = validator.validate(mud_parser.profile)\n\n    if not result.is_valid:\n        print(\"ERROR: MUD profile validation failed\", file=sys.stderr)\n        for error in result.errors:\n            print(f\"  - {error.message}\", file=sys.stderr)\n        sys.exit(1)\n\n    print(f\"Device: {mud_parser.mud.systeminfo}\")\n    print(f\"Generating {args.format} rules for {args.device_ip}\")\n\n    # Generate rules\n    if args.format == \"iptables\":\n        rules = mud_parser.export.to_iptables(device_ip=args.device_ip)\n    else:\n        rules = mud_parser.export.to_nftables(device_ip=args.device_ip)\n\n    # Output\n    if args.output:\n        Path(args.output).write_text(rules)\n        print(f\"Saved to {args.output}\")\n    else:\n        print(rules)\n\n    # Apply if requested\n    if args.apply:\n        print(\"\\nApplying rules...\")\n        if args.format == \"iptables\":\n            subprocess.run([\"bash\", \"-c\", rules], check=True)\n        else:\n            subprocess.run([\"nft\", \"-f\", \"-\"], input=rules, text=True, check=True)\n        print(\"Rules applied successfully\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"rfc-compliance/rfc8520/","title":"RFC 8520 Compliance","text":"<p>MudParser provides comprehensive support for RFC 8520 - Manufacturer Usage Description Specification.</p>"},{"location":"rfc-compliance/rfc8520/#overview","title":"Overview","text":"<p>RFC 8520 defines the MUD architecture that allows IoT manufacturers to specify the network behavior their devices require. This enables automated policy configuration in the network.</p>"},{"location":"rfc-compliance/rfc8520/#supported-features","title":"Supported Features","text":""},{"location":"rfc-compliance/rfc8520/#mud-container-ietf-mudmud","title":"MUD Container (ietf-mud:mud)","text":"Field Status Notes <code>mud-version</code> \u2705 Supported Only version 1 is supported <code>mud-url</code> \u2705 Supported Validated for HTTPS <code>last-update</code> \u2705 Supported Parsed as datetime <code>cache-validity</code> \u2705 Supported Validated 1-168 hours <code>is-supported</code> \u2705 Supported Boolean <code>systeminfo</code> \u2705 Supported Max 60 characters <code>mfg-name</code> \u2705 Supported Optional <code>model-name</code> \u2705 Supported Optional <code>firmware-rev</code> \u2705 Supported Optional <code>software-rev</code> \u2705 Supported Optional <code>documentation</code> \u2705 Supported Optional URL <code>extensions</code> \u2705 Supported List of extension names <code>from-device-policy</code> \u2705 Supported Outbound policy <code>to-device-policy</code> \u2705 Supported Inbound policy <code>mud-signature</code> \u26a0\ufe0f Parsed Signature validation not implemented"},{"location":"rfc-compliance/rfc8520/#acl-model-rfc-8519","title":"ACL Model (RFC 8519)","text":"Feature Status IPv4 ACL type \u2705 Supported IPv6 ACL type \u2705 Supported Ethernet ACL type \u2705 Supported Mixed ACL types \u2705 Supported ACE ordering \u2705 Preserved"},{"location":"rfc-compliance/rfc8520/#match-types","title":"Match Types","text":""},{"location":"rfc-compliance/rfc8520/#ipv4ipv6-matches","title":"IPv4/IPv6 Matches","text":"Field Status <code>protocol</code> / <code>next-header</code> \u2705 Supported <code>source-network</code> \u2705 Supported <code>destination-network</code> \u2705 Supported <code>dscp</code> \u2705 Supported <code>ecn</code> \u2705 Supported <code>length</code> \u2705 Supported <code>ttl</code> / <code>hop-limit</code> \u2705 Supported"},{"location":"rfc-compliance/rfc8520/#tcp-matches","title":"TCP Matches","text":"Field Status <code>source-port</code> \u2705 Supported <code>destination-port</code> \u2705 Supported <code>direction-initiated</code> \u2705 Supported <code>flags</code> \u2705 Supported"},{"location":"rfc-compliance/rfc8520/#udp-matches","title":"UDP Matches","text":"Field Status <code>source-port</code> \u2705 Supported <code>destination-port</code> \u2705 Supported <code>length</code> \u2705 Supported"},{"location":"rfc-compliance/rfc8520/#icmp-matches","title":"ICMP Matches","text":"Field Status <code>type</code> \u2705 Supported <code>code</code> \u2705 Supported"},{"location":"rfc-compliance/rfc8520/#ethernet-matches","title":"Ethernet Matches","text":"Field Status <code>source-mac-address</code> \u2705 Supported <code>destination-mac-address</code> \u2705 Supported <code>ethertype</code> \u2705 Supported"},{"location":"rfc-compliance/rfc8520/#port-operators","title":"Port Operators","text":"Operator Status <code>eq</code> (equals) \u2705 Supported <code>neq</code> (not equals) \u2705 Supported <code>lt</code> (less than) \u2705 Supported <code>gt</code> (greater than) \u2705 Supported <code>range</code> \u2705 Supported"},{"location":"rfc-compliance/rfc8520/#mud-specific-matches","title":"MUD-Specific Matches","text":"Match Type Status Description <code>manufacturer</code> \u2705 Supported Match by manufacturer URL authority <code>same-manufacturer</code> \u2705 Supported Match same manufacturer devices <code>model</code> \u2705 Supported Match same model (MUD URL) <code>local-networks</code> \u2705 Supported Match local network traffic <code>controller</code> \u2705 Supported Match controller class <code>my-controller</code> \u2705 Supported Match device-specific controller"},{"location":"rfc-compliance/rfc8520/#dns-extension-ietf-acldns","title":"DNS Extension (ietf-acldns)","text":"Field Status <code>src-dnsname</code> \u2705 Supported <code>dst-dnsname</code> \u2705 Supported"},{"location":"rfc-compliance/rfc8520/#actions","title":"Actions","text":"Action Status <code>accept</code> \u2705 Supported <code>drop</code> \u2705 Supported <code>reject</code> \u2705 Supported (treated as drop)"},{"location":"rfc-compliance/rfc8520/#standard-controller-urns","title":"Standard Controller URNs","text":"<p>MudParser recognizes these standard controller URNs:</p> <ul> <li><code>urn:ietf:params:mud:dns</code> - DNS server</li> <li><code>urn:ietf:params:mud:ntp</code> - NTP server</li> </ul>"},{"location":"rfc-compliance/rfc8520/#validation","title":"Validation","text":"<p>MudParser validates profiles against RFC 8520 requirements:</p> <ol> <li>Required fields - All mandatory fields must be present</li> <li>Version check - Only MUD version 1 is supported</li> <li>URL validation - MUD URL should use HTTPS</li> <li>Cache validity - Must be 1-168 hours</li> <li>ACL references - All referenced ACLs must exist</li> <li>Semantic checks - direction-initiated only for TCP</li> </ol>"},{"location":"rfc-compliance/rfc8520/#limitations","title":"Limitations","text":"<p>The following RFC 8520 features are not fully implemented:</p> <ol> <li>Signature verification - The <code>mud-signature</code> URL is parsed but signatures are not verified</li> <li>MUD URL delivery - DHCP/LLDP/X.509 delivery mechanisms are out of scope</li> <li>MUD manager - This library is a parser, not a full MUD manager implementation</li> </ol>"},{"location":"rfc-compliance/rfc8520/#references","title":"References","text":"<ul> <li>RFC 8520 - Manufacturer Usage Description Specification</li> <li>RFC 8519 - YANG Data Model for Network Access Control Lists</li> </ul>"},{"location":"rfc-compliance/rfc9761/","title":"RFC 9761 Compliance","text":"<p>MudParser provides support for RFC 9761 - Manufacturer Usage Description (MUD) for TLS and DTLS Profiles for IoT Devices.</p>"},{"location":"rfc-compliance/rfc9761/#overview","title":"Overview","text":"<p>RFC 9761 extends MUD to allow manufacturers to specify the TLS/DTLS behavior expected from their devices. This enables network security services to detect unexpected TLS usage that might indicate compromise.</p>"},{"location":"rfc-compliance/rfc9761/#supported-features","title":"Supported Features","text":""},{"location":"rfc-compliance/rfc9761/#tls-client-profile","title":"TLS Client Profile","text":"Field Status Description <code>tls-versions</code> \u2705 Supported Allowed TLS/DTLS versions <code>cipher-suites</code> \u2705 Supported Allowed cipher suites <code>spki-pins</code> \u2705 Supported Certificate pinning hashes <code>client-authentication</code> \u2705 Supported Client auth behavior <code>alpn-protocols</code> \u2705 Supported ALPN protocols <code>sni-required</code> \u2705 Supported SNI extension requirement"},{"location":"rfc-compliance/rfc9761/#tls-server-profile","title":"TLS Server Profile","text":"Field Status Description <code>tls-versions</code> \u2705 Supported Allowed TLS/DTLS versions <code>cipher-suites</code> \u2705 Supported Allowed cipher suites <code>client-authentication</code> \u2705 Supported Client auth requirements <code>alpn-protocols</code> \u2705 Supported ALPN protocols"},{"location":"rfc-compliance/rfc9761/#tls-versions","title":"TLS Versions","text":"Version Status TLS 1.0 \u2705 Supported (marked deprecated) TLS 1.1 \u2705 Supported (marked deprecated) TLS 1.2 \u2705 Supported TLS 1.3 \u2705 Supported DTLS 1.0 \u2705 Supported (marked deprecated) DTLS 1.2 \u2705 Supported DTLS 1.3 \u2705 Supported"},{"location":"rfc-compliance/rfc9761/#client-authentication","title":"Client Authentication","text":"Value Description <code>none</code> No client authentication <code>optional</code> Client auth optional <code>required</code> Client auth required"},{"location":"rfc-compliance/rfc9761/#usage","title":"Usage","text":""},{"location":"rfc-compliance/rfc9761/#parsing-tls-profiles","title":"Parsing TLS Profiles","text":"<pre><code>from mudparser.models.tls import TLSProfile, TLSVersion\n\n# Create from JSON data\ntls_data = {\n    \"client-profile\": {\n        \"tls-versions\": [\"tls-1.2\", \"tls-1.3\"],\n        \"cipher-suites\": [\n            \"TLS_AES_128_GCM_SHA256\",\n            \"TLS_AES_256_GCM_SHA384\"\n        ],\n        \"sni-required\": True\n    }\n}\n\nprofile = TLSProfile.from_json(tls_data)\n\n# Check versions\nprint(f\"Min TLS version: {profile.client_profile.get_min_version()}\")\nprint(f\"Allows deprecated: {profile.client_profile.allows_deprecated_versions()}\")\n</code></pre>"},{"location":"rfc-compliance/rfc9761/#security-analysis","title":"Security Analysis","text":"<pre><code># Check for security concerns\nconcerns = profile.has_security_concerns()\n\nfor concern in concerns:\n    print(f\"Warning: {concern}\")\n</code></pre> <p>Example output: <pre><code>Warning: Deprecated TLS versions allowed: tls-1.0, tls-1.1\nWarning: No certificate pinning configured\n</code></pre></p>"},{"location":"rfc-compliance/rfc9761/#accessing-tls-data","title":"Accessing TLS Data","text":"<pre><code># Get all versions\nall_versions = profile.get_all_tls_versions()\n\n# Get all cipher suites\nall_suites = profile.get_all_cipher_suites()\n\n# Check suite security\nfor suite in all_suites:\n    if not suite.is_secure():\n        print(f\"Insecure suite: {suite.name}\")\n</code></pre>"},{"location":"rfc-compliance/rfc9761/#data-models","title":"Data Models","text":""},{"location":"rfc-compliance/rfc9761/#tlsprofile","title":"TLSProfile","text":"<p>The main container for TLS configuration:</p> <pre><code>from mudparser.models.tls import TLSProfile\n\nprofile = TLSProfile(\n    client_profile=TLSClientProfile(...),\n    server_profile=TLSServerProfile(...),\n    description=\"Device TLS configuration\"\n)\n</code></pre>"},{"location":"rfc-compliance/rfc9761/#tlsversion","title":"TLSVersion","text":"<p>Enumeration of TLS/DTLS versions:</p> <pre><code>from mudparser.models.tls import TLSVersion\n\nversion = TLSVersion.TLS_1_3\nprint(version.is_dtls)       # False\nprint(version.is_deprecated) # False\n</code></pre>"},{"location":"rfc-compliance/rfc9761/#ciphersuite","title":"CipherSuite","text":"<p>Cipher suite specification:</p> <pre><code>from mudparser.models.tls import CipherSuite\n\nsuite = CipherSuite(\n    name=\"TLS_AES_128_GCM_SHA256\",\n    value=0x1301\n)\nprint(suite.is_secure())  # True\n</code></pre>"},{"location":"rfc-compliance/rfc9761/#spkihash","title":"SPKIHash","text":"<p>Certificate pinning hash:</p> <pre><code>from mudparser.models.tls import SPKIHash\n\npin = SPKIHash(\n    algorithm=\"sha256\",\n    value=\"base64_encoded_hash\"\n)\nprint(str(pin))  # sha256/base64_encoded_hash\n</code></pre>"},{"location":"rfc-compliance/rfc9761/#security-recommendations","title":"Security Recommendations","text":"<ol> <li>Use TLS 1.2+ - Avoid deprecated versions (TLS 1.0, 1.1)</li> <li>Use strong ciphers - Avoid NULL, EXPORT, DES, RC4, MD5</li> <li>Enable SNI - Required for proper certificate validation</li> <li>Use certificate pinning - Helps prevent MITM attacks</li> <li>Require mutual auth - For high-security devices</li> </ol>"},{"location":"rfc-compliance/rfc9761/#integration-with-mud-profiles","title":"Integration with MUD Profiles","text":"<p>TLS profiles can be integrated with MUD profiles to provide complete device behavior specification:</p> <pre><code>{\n  \"ietf-mud:mud\": {\n    \"mud-version\": 1,\n    ...\n  },\n  \"ietf-access-control-list:access-lists\": {\n    ...\n  },\n  \"ietf-mud-tls:mud-tls\": {\n    \"client-profile\": {\n      \"tls-versions\": [\"tls-1.2\", \"tls-1.3\"]\n    }\n  }\n}\n</code></pre>"},{"location":"rfc-compliance/rfc9761/#references","title":"References","text":"<ul> <li>RFC 9761 - MUD (D)TLS Profiles for IoT Devices</li> <li>RFC 8446 - TLS 1.3</li> </ul>"},{"location":"user-guide/cli-usage/","title":"CLI Usage","text":"<p>MudParser provides a full-featured command-line interface for working with MUD profiles.</p>"},{"location":"user-guide/cli-usage/#installation","title":"Installation","text":"<p>The CLI is included with the main package:</p> <pre><code>pip install mudparser\n</code></pre> <p>Verify installation:</p> <pre><code>mudparser --version\n</code></pre>"},{"location":"user-guide/cli-usage/#commands-overview","title":"Commands Overview","text":"Command Description <code>validate</code> Validate a MUD profile <code>info</code> Display profile information <code>rules</code> Print rules in human-readable format <code>export</code> Export to various formats <code>fetch</code> Fetch profile from URL <code>diff</code> Compare two profiles <code>demo</code> Launch web demo (requires extras)"},{"location":"user-guide/cli-usage/#validate-command","title":"Validate Command","text":"<p>Check a MUD profile for RFC 8520 compliance.</p> <pre><code># Basic validation\nmudparser validate device.mud.json\n\n# Strict mode (warnings become errors)\nmudparser validate device.mud.json --strict\n\n# JSON output for scripting\nmudparser validate device.mud.json --json\n</code></pre>"},{"location":"user-guide/cli-usage/#options","title":"Options","text":"Option Short Description <code>--strict</code> <code>-s</code> Treat warnings as errors <code>--json</code> <code>-j</code> Output as JSON"},{"location":"user-guide/cli-usage/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> - Valid profile</li> <li><code>1</code> - Validation failed</li> </ul>"},{"location":"user-guide/cli-usage/#info-command","title":"Info Command","text":"<p>Display detailed information about a MUD profile.</p> <pre><code># Display profile info\nmudparser info device.mud.json\n\n# JSON output\nmudparser info device.mud.json --json\n</code></pre>"},{"location":"user-guide/cli-usage/#example-output","title":"Example Output","text":"<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 MUD Profile \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 My IoT Device                                   \u2502\n\u2502 URL: https://example.com/device.json            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Property        \u2503 Value                          \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 MUD Version     \u2502 1                              \u2502\n\u2502 Last Update     \u2502 2024-01-15T10:00:00Z           \u2502\n\u2502 Cache Validity  \u2502 48 hours                       \u2502\n\u2502 Supported       \u2502 Yes                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Direction             \u2503 ACLs \u2503 Rules \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 From Device (Outbound)\u2502 1    \u2502 3     \u2502\n\u2502 To Device (Inbound)   \u2502 1    \u2502 2     \u2502\n\u2502 Total                 \u2502 2    \u2502 5     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReferenced DNS Names:\n  - api.example.com\n  - updates.example.com\n\nReferenced Ports:\n  TCP: 80, 443\n  UDP: 53\n</code></pre>"},{"location":"user-guide/cli-usage/#rules-command","title":"Rules Command","text":"<p>Print all rules in human-readable format.</p> <pre><code>mudparser rules device.mud.json\n</code></pre>"},{"location":"user-guide/cli-usage/#example-output_1","title":"Example Output","text":"<pre><code>============================================================\nMUD Profile: My IoT Device\nURL: https://example.com/device.json\nVersion: 1\n============================================================\n\n### FROM-DEVICE POLICY (Outbound) ###\n\n##### ACL::from-ipv4-device::START #####\nType: ipv4-acl-type\n\n  [FROM] ALLOW TCP to api.example.com port eq 443\n  [FROM] ALLOW TCP to updates.example.com port eq 443\n\n(implicit deny all)\n##### ACL::from-ipv4-device::END #####\n</code></pre>"},{"location":"user-guide/cli-usage/#export-command","title":"Export Command","text":"<p>Export profiles to various formats.</p> <pre><code># Export to JSON (stdout)\nmudparser export device.mud.json -f json\n\n# Export to YAML\nmudparser export device.mud.json -f yaml\n\n# Export to iptables (requires device IP)\nmudparser export device.mud.json -f iptables -d 192.168.1.100\n\n# Export to nftables\nmudparser export device.mud.json -f nftables -d 192.168.1.100\n\n# Export to Cisco ACL\nmudparser export device.mud.json -f cisco\n\n# Export to pfSense\nmudparser export device.mud.json -f pfsense -d 192.168.1.100\n\n# Save to file\nmudparser export device.mud.json -f iptables -d 192.168.1.100 -o rules.sh\n</code></pre>"},{"location":"user-guide/cli-usage/#options_1","title":"Options","text":"Option Short Description <code>--format</code> <code>-f</code> Export format (required) <code>--device-ip</code> <code>-d</code> Device IP (required for firewall formats) <code>--output</code> <code>-o</code> Output file path"},{"location":"user-guide/cli-usage/#supported-formats","title":"Supported Formats","text":"<ul> <li><code>json</code> - JSON format</li> <li><code>yaml</code> - YAML format</li> <li><code>iptables</code> - Linux iptables</li> <li><code>nftables</code> - Linux nftables</li> <li><code>cisco</code> - Cisco IOS ACL</li> <li><code>pfsense</code> - pfSense XML</li> </ul>"},{"location":"user-guide/cli-usage/#fetch-command","title":"Fetch Command","text":"<p>Fetch and optionally validate a MUD profile from a URL.</p> <pre><code># Fetch and display summary\nmudparser fetch https://example.com/device.mud.json\n\n# Fetch and validate\nmudparser fetch https://example.com/device.mud.json --validate\n\n# Fetch and save to file\nmudparser fetch https://example.com/device.mud.json -o device.json\n</code></pre>"},{"location":"user-guide/cli-usage/#options_2","title":"Options","text":"Option Short Description <code>--validate</code> <code>-v</code> Validate the fetched profile <code>--output</code> <code>-o</code> Save to file"},{"location":"user-guide/cli-usage/#diff-command","title":"Diff Command","text":"<p>Compare two MUD profiles.</p> <pre><code>mudparser diff old_device.json new_device.json\n</code></pre>"},{"location":"user-guide/cli-usage/#example-output_2","title":"Example Output","text":"<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Comparing MUD Profiles \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 File 1: old_device.json                      \u2502\n\u2502 File 2: new_device.json                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Property    \u2503 File 1   \u2503 File 2   \u2503 Match \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 System Info \u2502 Device   \u2502 Device   \u2502 Yes   \u2502\n\u2502 Version     \u2502 1        \u2502 1        \u2502 Yes   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Metric            \u2503 File 1 \u2503 File 2 \u2503 Diff \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 Total Rules       \u2502 5      \u2502 7      \u2502 +2   \u2502\n\u2502 From-Device Rules \u2502 3      \u2502 4      \u2502 +1   \u2502\n\u2502 To-Device Rules   \u2502 2      \u2502 3      \u2502 +1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDNS Name Changes:\n  + new-api.example.com\n</code></pre>"},{"location":"user-guide/cli-usage/#demo-command","title":"Demo Command","text":"<p>Launch the interactive Streamlit demo application.</p> <pre><code># Requires demo extras\npip install mudparser[demo]\n\n# Launch demo\nmudparser demo\n</code></pre>"},{"location":"user-guide/cli-usage/#global-options","title":"Global Options","text":"Option Short Description <code>--version</code> <code>-v</code> Show version <code>--help</code> Show help"},{"location":"user-guide/cli-usage/#shell-completion","title":"Shell Completion","text":"<p>Generate shell completion scripts:</p> <pre><code># Bash\nmudparser --install-completion bash\n\n# Zsh\nmudparser --install-completion zsh\n\n# Fish\nmudparser --install-completion fish\n</code></pre>"},{"location":"user-guide/cli-usage/#scripting","title":"Scripting","text":"<p>Use JSON output for scripting:</p> <pre><code># Get info as JSON\ninfo=$(mudparser info device.mud.json --json)\ndevice_name=$(echo $info | jq -r '.systeminfo')\n\n# Check validation\nif mudparser validate device.mud.json --json | jq -e '.is_valid' &gt; /dev/null; then\n    echo \"Profile is valid\"\nelse\n    echo \"Profile is invalid\"\nfi\n\n# Export rules\nmudparser export device.mud.json -f iptables -d $(get_device_ip) | bash\n</code></pre>"},{"location":"user-guide/exporting/","title":"Exporting","text":"<p>MudParser can export MUD profiles to various formats including data formats and firewall rules.</p>"},{"location":"user-guide/exporting/#export-formats","title":"Export Formats","text":"Format Description Use Case <code>json</code> JSON data format Data interchange <code>yaml</code> YAML data format Human-readable config <code>iptables</code> Linux iptables rules Linux firewalls <code>nftables</code> Linux nftables rules Modern Linux firewalls <code>cisco</code> Cisco IOS ACLs Cisco network devices <code>pfsense</code> pfSense XML BSD firewalls"},{"location":"user-guide/exporting/#basic-export","title":"Basic Export","text":"<pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Access the exporter\nexporter = parser.export\n</code></pre>"},{"location":"user-guide/exporting/#data-format-exports","title":"Data Format Exports","text":""},{"location":"user-guide/exporting/#json-export","title":"JSON Export","text":"<pre><code># Default formatting\njson_output = parser.export.to_json()\n\n# Custom formatting\njson_output = parser.export.to_json(indent=4, sort_keys=True)\n\n# Save to file\nwith open(\"output.json\", \"w\") as f:\n    f.write(parser.export.to_json())\n</code></pre>"},{"location":"user-guide/exporting/#yaml-export","title":"YAML Export","text":"<pre><code>yaml_output = parser.export.to_yaml()\n\n# With flow style\nyaml_output = parser.export.to_yaml(default_flow_style=True)\n</code></pre>"},{"location":"user-guide/exporting/#firewall-rule-exports","title":"Firewall Rule Exports","text":""},{"location":"user-guide/exporting/#iptables-linux","title":"iptables (Linux)","text":"<p>Generate iptables rules for Linux:</p> <pre><code>rules = parser.export.to_iptables(\n    device_ip=\"192.168.1.100\",        # Required: Device IP\n    device_interface=\"eth0\",           # Optional: Interface\n    chain_prefix=\"MUD\",                # Optional: Chain name prefix\n    include_comments=True,             # Optional: Add comments\n)\nprint(rules)\n</code></pre> <p>Output: <pre><code>#!/bin/bash\n# IPTables rules generated from MUD profile\n# Device: My IoT Device\n# Device IP: 192.168.1.100\n\n# Create custom chains\niptables -N MUD_FROM_MY_IOT_DEVICE 2&gt;/dev/null || iptables -F MUD_FROM_MY_IOT_DEVICE\niptables -N MUD_TO_MY_IOT_DEVICE 2&gt;/dev/null || iptables -F MUD_TO_MY_IOT_DEVICE\n\n# Jump to custom chains\niptables -A FORWARD -s 192.168.1.100 -j MUD_FROM_MY_IOT_DEVICE\niptables -A FORWARD -d 192.168.1.100 -j MUD_TO_MY_IOT_DEVICE\n\n# FROM-DEVICE rules\niptables -A MUD_FROM_MY_IOT_DEVICE -s 192.168.1.100 -p tcp -d api.example.com --dport 443 -m state --state NEW,ESTABLISHED -m comment --comment \"allow-https\" -j ACCEPT\n\n# Default deny\niptables -A MUD_FROM_MY_IOT_DEVICE -j DROP\niptables -A MUD_TO_MY_IOT_DEVICE -j DROP\n</code></pre></p>"},{"location":"user-guide/exporting/#nftables-linux","title":"nftables (Linux)","text":"<p>Generate modern nftables rules:</p> <pre><code>rules = parser.export.to_nftables(\n    device_ip=\"192.168.1.100\",\n    table_name=\"mud_rules\",            # Optional: Table name\n    include_comments=True,\n)\n</code></pre> <p>Output: <pre><code>#!/usr/sbin/nft -f\n# nftables rules generated from MUD profile\n\ntable inet mud_rules {\n    chain from_my_iot_device {\n        type filter hook forward priority 0; policy drop;\n\n        ip saddr 192.168.1.100 tcp dport 443 ct state new,established counter accept comment \"allow-https\"\n\n        ip saddr 192.168.1.100 counter drop\n    }\n}\n</code></pre></p>"},{"location":"user-guide/exporting/#cisco-ios-acl","title":"Cisco IOS ACL","text":"<p>Generate Cisco IOS extended access lists:</p> <pre><code>rules = parser.export.to_cisco_acl(\n    acl_number_start=100,              # Optional: Starting ACL number\n    include_remarks=True,              # Optional: Include remarks\n)\n</code></pre> <p>Output: <pre><code>!\n! Cisco IOS ACLs generated from MUD profile\n!\nip access-list extended 100\n remark MUD ACL: from-ipv4-device\n remark ACE: allow-https\n permit tcp any host api.example.com eq 443\n deny ip any any\n</code></pre></p>"},{"location":"user-guide/exporting/#pfsense","title":"pfSense","text":"<p>Generate pfSense XML configuration:</p> <pre><code>rules = parser.export.to_pfsense(\n    device_ip=\"192.168.1.100\",\n    interface=\"lan\",                   # Optional: Interface name\n)\n</code></pre> <p>Output is XML that can be imported into pfSense.</p>"},{"location":"user-guide/exporting/#generic-export-method","title":"Generic Export Method","text":"<p>Use the <code>export()</code> method for any format:</p> <pre><code>from mudparser.exporters import ExportFormat\n\n# By string\noutput = parser.export.export(\"iptables\", device_ip=\"192.168.1.100\")\n\n# By enum\noutput = parser.export.export(ExportFormat.NFTABLES, device_ip=\"192.168.1.100\")\n</code></pre>"},{"location":"user-guide/exporting/#cli-export","title":"CLI Export","text":"<p>Export from the command line:</p> <pre><code># Export to JSON (stdout)\nmudparser export device.mud.json -f json\n\n# Export to file\nmudparser export device.mud.json -f yaml -o output.yaml\n\n# Export iptables (requires device IP)\nmudparser export device.mud.json -f iptables -d 192.168.1.100\n\n# Export nftables to file\nmudparser export device.mud.json -f nftables -d 192.168.1.100 -o rules.nft\n\n# Export Cisco ACL\nmudparser export device.mud.json -f cisco\n\n# Export pfSense\nmudparser export device.mud.json -f pfsense -d 192.168.1.100 -o pfsense_rules.xml\n</code></pre>"},{"location":"user-guide/exporting/#export-summary","title":"Export Summary","text":"<p>Get information about what will be exported:</p> <pre><code>summary = parser.export.get_summary()\n\nprint(f\"Device: {summary['device_info']}\")\nprint(f\"From-device rules: {summary['from_device_rules']}\")\nprint(f\"To-device rules: {summary['to_device_rules']}\")\nprint(f\"DNS names: {summary['dns_names']}\")\nprint(f\"Ports: {summary['ports']}\")\nprint(f\"Supported formats: {summary['supported_formats']}\")\n</code></pre>"},{"location":"user-guide/exporting/#handling-dns-names","title":"Handling DNS Names","text":"<p>Note that firewall rules export DNS names as-is. For production use:</p> <ol> <li>iptables/nftables: DNS names will be resolved at rule insertion time</li> <li>Cisco: Use FQDN ACLs or resolve names manually</li> <li>pfSense: Supports DNS aliases</li> </ol> <p>Consider using tools like <code>dnsmasq</code> or network-level DNS resolution.</p>"},{"location":"user-guide/exporting/#best-practices","title":"Best Practices","text":"<ol> <li>Test rules before deploying to production</li> <li>Resolve DNS names to IPs where needed</li> <li>Include logging for denied traffic</li> <li>Review default deny rules match your security policy</li> <li>Backup existing rules before applying new ones</li> </ol>"},{"location":"user-guide/exporting/#error-handling","title":"Error Handling","text":"<pre><code>from mudparser.exceptions import MUDExportError\n\ntry:\n    rules = parser.export.to_iptables(device_ip=\"192.168.1.100\")\nexcept MUDExportError as e:\n    print(f\"Export failed: {e.message}\")\n    print(f\"Format: {e.export_format}\")\n</code></pre>"},{"location":"user-guide/parsing-mud-files/","title":"Parsing MUD Files","text":"<p>MudParser provides multiple ways to parse MUD profiles from various sources.</p>"},{"location":"user-guide/parsing-mud-files/#parsing-from-file","title":"Parsing from File","text":"<p>The most common way to parse a MUD profile:</p> <pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"path/to/device.mud.json\")\n</code></pre> <p>You can also use <code>pathlib.Path</code>:</p> <pre><code>from pathlib import Path\n\nparser = MUDParser.from_file(Path(\"device.mud.json\"))\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#parsing-from-string","title":"Parsing from String","text":"<p>Parse a JSON string directly:</p> <pre><code>json_string = '''\n{\n  \"ietf-mud:mud\": { ... },\n  \"ietf-access-control-list:access-lists\": { ... }\n}\n'''\n\nparser = MUDParser.from_string(json_string)\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#parsing-from-dictionary","title":"Parsing from Dictionary","text":"<p>Parse from a Python dictionary:</p> <pre><code>data = {\n    \"ietf-mud:mud\": {\n        \"mud-version\": 1,\n        \"mud-url\": \"https://example.com/device.json\",\n        # ...\n    },\n    \"ietf-access-control-list:access-lists\": {\n        \"acl\": [...]\n    }\n}\n\nparser = MUDParser.from_dict(data)\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#parsing-from-url","title":"Parsing from URL","text":"<p>Fetch and parse a MUD profile from a URL:</p> <pre><code>parser = MUDParser.from_url(\"https://example.com/device.mud.json\")\n</code></pre> <p>With options:</p> <pre><code>parser = MUDParser.from_url(\n    \"https://example.com/device.mud.json\",\n    timeout=30.0,      # Request timeout in seconds\n    verify_ssl=True,   # Verify SSL certificates\n)\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#async-url-fetching","title":"Async URL Fetching","text":"<p>For async applications:</p> <pre><code>import asyncio\n\nasync def fetch_profile():\n    parser = await MUDParser.from_url_async(\"https://example.com/device.mud.json\")\n    return parser\n\nparser = asyncio.run(fetch_profile())\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#parsing-from-file-object","title":"Parsing from File Object","text":"<p>Parse from an open file object:</p> <pre><code>with open(\"device.mud.json\") as f:\n    parser = MUDParser.from_file_object(f)\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#accessing-parsed-data","title":"Accessing Parsed Data","text":""},{"location":"user-guide/parsing-mud-files/#mud-container","title":"MUD Container","text":"<p>Access the main MUD metadata:</p> <pre><code># Version and URL\nprint(parser.mud.mud_version)      # 1\nprint(parser.mud.mud_url)          # https://example.com/device.json\n\n# Timestamps and caching\nprint(parser.mud.last_update)      # datetime object\nprint(parser.mud.cache_validity)   # Hours (1-168)\n\n# Device information\nprint(parser.mud.systeminfo)       # \"My Device\"\nprint(parser.mud.is_supported)     # True/False\nprint(parser.mud.mfg_name)         # Manufacturer name (optional)\nprint(parser.mud.model_name)       # Model name (optional)\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#access-control-lists","title":"Access Control Lists","text":"<p>Access ACLs in the profile:</p> <pre><code># Get all ACLs\nfor acl in parser.profile.acls.acl:\n    print(f\"ACL: {acl.name}, Type: {acl.acl_type}\")\n\n# Get ACL by name\nacl = parser.get_acl(\"from-ipv4-device\")\nif acl:\n    print(f\"Found ACL with {len(acl)} entries\")\n\n# Get ACLs by policy direction\nfrom_acls = parser.get_from_device_acls()  # Outbound\nto_acls = parser.get_to_device_acls()      # Inbound\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#access-control-entries","title":"Access Control Entries","text":"<p>Access individual ACE rules:</p> <pre><code>acl = parser.get_acl(\"from-ipv4-device\")\n\nfor entry in acl.entries:\n    print(f\"ACE: {entry.name}\")\n    print(f\"  Action: {entry.actions.forwarding}\")\n\n    # Check matches\n    if entry.matches.ipv4:\n        print(f\"  Protocol: {entry.matches.ipv4.protocol}\")\n    if entry.matches.tcp:\n        if entry.matches.tcp.dst_port:\n            print(f\"  Dest Port: {entry.matches.tcp.dst_port.port}\")\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#get-all-entries-with-direction","title":"Get All Entries with Direction","text":"<pre><code>for direction, entry in parser.get_all_entries():\n    print(f\"[{direction}] {entry.name}: {entry.actions.forwarding}\")\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#extracting-resources","title":"Extracting Resources","text":""},{"location":"user-guide/parsing-mud-files/#dns-names","title":"DNS Names","text":"<p>Get all DNS names referenced in the profile:</p> <pre><code>dns_names = parser.get_dns_names()\nprint(f\"Referenced hosts: {dns_names}\")\n# {'api.example.com', 'updates.example.com'}\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#ports","title":"Ports","text":"<p>Get all ports referenced:</p> <pre><code>ports = parser.get_ports()\nprint(f\"TCP ports: {ports['tcp']}\")  # {443, 80}\nprint(f\"UDP ports: {ports['udp']}\")  # {53}\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#profile-summary","title":"Profile Summary","text":"<p>Get a complete summary:</p> <pre><code>summary = parser.get_summary()\n\nprint(f\"Device: {summary['systeminfo']}\")\nprint(f\"Total Rules: {summary['total_rules']}\")\nprint(f\"From-Device ACLs: {summary['from_device_acls']}\")\nprint(f\"To-Device ACLs: {summary['to_device_acls']}\")\n</code></pre>"},{"location":"user-guide/parsing-mud-files/#printing-rules","title":"Printing Rules","text":"<p>Display rules in human-readable format:</p> <pre><code>parser.print_rules()\n</code></pre> <p>Output: <pre><code>============================================================\nMUD Profile: My IoT Device\nURL: https://example.com/device.json\nVersion: 1\nLast Update: 2024-01-15T10:00:00\nSupported: True\n============================================================\n\n### FROM-DEVICE POLICY (Outbound) ###\n\n##### ACL::from-ipv4-device::START #####\nType: ipv4-acl-type\n\n  [FROM] ALLOW TCP to api.example.com port eq 443\n\n(implicit deny all)\n##### ACL::from-ipv4-device::END #####\n</code></pre></p>"},{"location":"user-guide/parsing-mud-files/#error-handling","title":"Error Handling","text":"<p>Handle parsing errors appropriately:</p> <pre><code>from mudparser import MUDParser\nfrom mudparser.exceptions import (\n    MUDFileNotFoundError,\n    MUDSchemaError,\n    MUDNetworkError,\n    MUDValidationError,\n)\n\ntry:\n    parser = MUDParser.from_file(\"device.mud.json\")\nexcept MUDFileNotFoundError as e:\n    print(f\"File not found: {e.file_path}\")\nexcept MUDSchemaError as e:\n    print(f\"Invalid JSON structure: {e}\")\nexcept MUDValidationError as e:\n    print(f\"Validation failed: {e}\")\n</code></pre> <p>For URL fetching:</p> <pre><code>try:\n    parser = MUDParser.from_url(\"https://example.com/device.json\")\nexcept MUDNetworkError as e:\n    print(f\"Network error: {e.message}\")\n    if e.status_code:\n        print(f\"HTTP status: {e.status_code}\")\n</code></pre>"},{"location":"user-guide/validation/","title":"Validation","text":"<p>MudParser provides comprehensive validation for MUD profiles to ensure RFC 8520 compliance.</p>"},{"location":"user-guide/validation/#basic-validation","title":"Basic Validation","text":"<p>Validate a parsed profile:</p> <pre><code>from mudparser import MUDParser\n\nparser = MUDParser.from_file(\"device.mud.json\")\n\n# Returns list of error messages\nerrors = parser.validate()\n\nif errors:\n    print(\"Validation issues found:\")\n    for error in errors:\n        print(f\"  - {error}\")\nelse:\n    print(\"Profile is valid!\")\n</code></pre>"},{"location":"user-guide/validation/#strict-validation","title":"Strict Validation","text":"<p>Use strict mode to raise an exception on any issue:</p> <pre><code>from mudparser.exceptions import MUDValidationError\n\ntry:\n    parser.validate(strict=True)\n    print(\"Validation passed!\")\nexcept MUDValidationError as e:\n    print(f\"Validation failed: {e.message}\")\n    for err in e.errors:\n        print(f\"  - {err['message']}\")\n</code></pre>"},{"location":"user-guide/validation/#using-the-validator-directly","title":"Using the Validator Directly","text":"<p>For more control, use the <code>MUDValidator</code> class:</p> <pre><code>from mudparser.validator import MUDValidator, ValidationSeverity\n\nvalidator = MUDValidator(strict=False)\nresult = validator.validate(parser.profile)\n\nprint(f\"Valid: {result.is_valid}\")\nprint(f\"Errors: {result.error_count}\")\nprint(f\"Warnings: {result.warning_count}\")\n\n# Access issues by severity\nfor issue in result.errors:\n    print(f\"ERROR: {issue.message}\")\n\nfor issue in result.warnings:\n    print(f\"WARNING: {issue.message}\")\n</code></pre>"},{"location":"user-guide/validation/#validation-checks","title":"Validation Checks","text":""},{"location":"user-guide/validation/#structure-validation","title":"Structure Validation","text":"<p>MudParser validates the basic structure:</p> <ul> <li>Required <code>ietf-mud:mud</code> container</li> <li>Required <code>ietf-access-control-list:access-lists</code> container</li> <li>Required fields within MUD container</li> </ul>"},{"location":"user-guide/validation/#mud-container-validation","title":"MUD Container Validation","text":"Field Validation <code>mud-version</code> Must be 1 (only supported version) <code>mud-url</code> Must be valid HTTPS URL (warning if HTTP) <code>cache-validity</code> Must be 1-168 hours <code>systeminfo</code> Max 60 characters"},{"location":"user-guide/validation/#acl-reference-validation","title":"ACL Reference Validation","text":"<ul> <li>All ACLs referenced in policies must exist</li> <li>Unreferenced ACLs generate warnings</li> </ul>"},{"location":"user-guide/validation/#acl-type-validation","title":"ACL Type Validation","text":"<ul> <li>IPv4 ACLs shouldn't have IPv6 matches</li> <li>IPv6 ACLs shouldn't have IPv4 matches</li> </ul>"},{"location":"user-guide/validation/#ace-match-validation","title":"ACE Match Validation","text":"<ul> <li><code>direction-initiated</code> only valid for TCP</li> <li>Port ranges must have upper &gt; lower</li> </ul>"},{"location":"user-guide/validation/#mud-specific-match-validation","title":"MUD-Specific Match Validation","text":"<ul> <li>Controller URNs are checked against standard URNs</li> <li>Non-standard URNs generate informational messages</li> </ul>"},{"location":"user-guide/validation/#validation-severity-levels","title":"Validation Severity Levels","text":"Severity Description <code>ERROR</code> Profile is invalid, must be fixed <code>WARNING</code> Potential issue, should be addressed <code>INFO</code> Informational, best practice suggestion"},{"location":"user-guide/validation/#validation-result","title":"Validation Result","text":"<p>Access detailed validation results:</p> <pre><code>result = validator.validate(profile)\n\n# Check overall validity\nif result.is_valid:\n    print(\"Profile passes validation\")\n\n# Get counts\nprint(f\"Errors: {result.error_count}\")\nprint(f\"Warnings: {result.warning_count}\")\n\n# Iterate over all issues\nfor issue in result.issues:\n    print(f\"[{issue.severity.value}] {issue.message}\")\n    if issue.path:\n        print(f\"  Path: {issue.path}\")\n    if issue.code:\n        print(f\"  Code: {issue.code}\")\n\n# Convert to dictionary\nresult_dict = result.to_dict()\n</code></pre>"},{"location":"user-guide/validation/#validating-raw-json","title":"Validating Raw JSON","text":"<p>Validate JSON before parsing:</p> <pre><code>from mudparser.validator import validate_json\n\ndata = {\n    \"ietf-mud:mud\": {...},\n    \"ietf-access-control-list:access-lists\": {...}\n}\n\nresult = validate_json(data)\n\nif not result.is_valid:\n    for error in result.errors:\n        print(f\"Error: {error.message}\")\n</code></pre>"},{"location":"user-guide/validation/#cli-validation","title":"CLI Validation","text":"<p>Validate from the command line:</p> <pre><code># Basic validation\nmudparser validate device.mud.json\n\n# Strict validation\nmudparser validate device.mud.json --strict\n\n# JSON output for scripting\nmudparser validate device.mud.json --json\n</code></pre> <p>Example output: <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Validation Result \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Profile is valid                                          \u2502\n\u2502 Errors: 0 | Warnings: 2                                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Severity  \u2503 Message                           \u2503 Path    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 WARNING   \u2502 Manufacturer name not specified   \u2502 -       \u2502\n\u2502 INFO      \u2502 No documentation URL provided     \u2502 -       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"user-guide/validation/#common-validation-errors","title":"Common Validation Errors","text":""},{"location":"user-guide/validation/#missing-acl-reference","title":"Missing ACL Reference","text":"<pre><code>ERROR: ACL 'from-ipv4-device' referenced in from-device-policy does not exist\n</code></pre> <p>Fix: Ensure all ACLs referenced in policies are defined in <code>access-lists</code>.</p>"},{"location":"user-guide/validation/#invalid-cache-validity","title":"Invalid Cache Validity","text":"<pre><code>ERROR: Cache validity 200 outside valid range (1-168)\n</code></pre> <p>Fix: Set <code>cache-validity</code> to a value between 1 and 168 hours.</p>"},{"location":"user-guide/validation/#http-url-warning","title":"HTTP URL Warning","text":"<pre><code>WARNING: MUD URL should use HTTPS: http://example.com/device.json\n</code></pre> <p>Fix: Use HTTPS for the MUD URL as required by RFC 8520.</p>"},{"location":"user-guide/validation/#custom-validation","title":"Custom Validation","text":"<p>Extend validation with custom checks:</p> <pre><code>from mudparser.validator import MUDValidator, ValidationIssue, ValidationSeverity\n\nclass CustomValidator(MUDValidator):\n    def validate(self, profile):\n        result = super().validate(profile)\n\n        # Add custom check\n        if not profile.mud.mfg_name:\n            result.issues.append(ValidationIssue(\n                severity=ValidationSeverity.WARNING,\n                message=\"Manufacturer name is recommended for production\",\n                code=\"CUSTOM_MFG_CHECK\",\n            ))\n\n        return result\n</code></pre>"}]}